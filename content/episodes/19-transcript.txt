Benvenuti su GITBAR il podcast dedicato al mondo dei full stack developer, i mezzo artigiani, i mezzo artisti che ogni giorno infilano le mani nel fango per creare nel modo più efficiente possibile quei prodotti digitali che quotidianamente usiamo. Bene e benvenuti, 19esima puntata di GITBAR, ci stiamo avvicinando alla ventesima quindi a uno dei primi traguardi che mi son posto quando ho iniziato a registrare questo podcast e in qualche modo ci stiamo avvicinando, scomodando degli argomenti che si fanno sempre più interessanti ma anche sempre più articolati. Infatti l'argomento che ho preparato per oggi vuole essere qualcosa di veramente interessante che sconvolgerà il mondo della programmazione web e che è abbastanza lontano da quello che i full stack developer utilizzano quotidianamente ed è magari più vicino al mondo dei programmatori C o dei programmatori RUST o dei programmatori di giochi quindi cerchiamo di esplorare un nuovo mondo rimanendo sempre concentrati e focalizzati su quello che è però lo sviluppo web anche perché lo sviluppo web si sta evolvendo a una velocità molto sostenuta e il mondo che vi andrò a raccontare oggi è una delle sue evoluzioni più spinte. Prima di farlo però voglio ricordarvi i nostri contatti. Potete entrare in contatto con Gitbar direttamente nel sito www.gitbar.it là trovate i nostri episodi pubblicati settimanalmente, trovate la descrizione dell'episodio, la potrete ascoltare e leggere la transcription. La transcription viene generata in modo del tutto automatico dai servizi di Amazon e quindi insomma non è perfetta ma ci aiuta a fare l'indicizzazione nei motori di ricerca. Detto questo è ricordato anche che potete scriverci direttamente a info@gitbar.it o con messaggio privato a Twitter @brainrepo possiamo iniziare la trasmissione di oggi e per iniziare mi vesto da Mario Bros, indosso la tutina, mi doto di chiave inglese e mettiamo le mani sul codice a basso livello prima però di mettere le mani in mezzo agli ingranaggi e provare a vedere cosa ci sta, a quel livello occorre in qualche modo fare un inquadramento generale, provare a capire cosa è successo e partiamo dal 1995 quando venne rilasciato il linguaggio javascript lo scopo del linguaggio javascript era di quello di dare delle funzionalità della dinamicità alle pagine web e farlo cercando di essere più veloce possibile naturalmente nel 95 negli anni a seguire javascript non era così veloce portandolo nel tempo poi quasi a una disadozione, una disaffezione. Io ricordo appunto i primi anni di università che non tutti amavamo javascript, anzi pochissimi lo utilizzavano. Quindi o generavamo delle pagine statiche senza interattività oppure se volevamo fare qualcosa di più interattivo perché no ci buttavamo tool come flash quindi come action script oppure creavamo delle applet java. Naturalmente poi la guerra tra i browser che ne seguì negli anni immediatamente successivi fu da catalizzatore per lo sviluppo dell'engine javascript che diventò progressivamente più performante e più veloce anche grazie all'introduzione del JIT, della compilazione appunto Just In Time. Questo tipo di compilazione e di boost alle performance di JavaScript hanno poi portato lo stesso linguaggio a uscire fuori dall'ecosistema dei browser e arrivare nello sviluppo, per esempio, delle applicazioni Latoserver con Node.js e delle applicazioni anche desktop con tool come Electron e simili. Quindi questo boost di performance che c'è stato nel 2008 ha veramente stravolto la vita di questo linguaggio che è nato per essere un tool a supporto delle pagine web e che aveva come limite appunto le performance e trasformarlo in uno dei linguaggi, se non il linguaggio più adottato dagli sviluppatori di tutto il mondo. Questo aumento di performance dovuto all'introduzione del GTI Compiler beh, in qualche modo ha aperto le porte a una vera rivoluzione nel mondo del browser. E infatti il mondo del browser si è aperto a dei mondi che prima gli erano preclusi. Basti pensare che abbiamo una versione di Google Earth che gira appunto nel nostro browser. Naturalmente oltre a quello abbiamo dei motori 3D che girano su browser, abbiamo sistemi per l'editing grafico, sistemi per la visualizzazione di dati per indagini scientifiche, comunque sistemi che portano a limite le risorse e che in realtà portano javascript a raggiungere il tappo delle performance. Quindi si è avuta la necessità di superare questo limite, come tutte le cose in tecnologia quando si supera una barriera ci si porta avanti fino a raggiungerne un'altra finché nel 2015 lì è stato introdotto il WebAssembly ed è stato introdotto partendo da un assunto molto semplice con la rivoluzione del javascript si è in qualche modo portato il linguaggio javascript che era nato nel web nel mondo del nativo. Con il WebAssembly oggi si porta quello che è il mondo nativo nel web. Per farlo si è pensato di realizzare un linguaggio a basso livello che giri sul browser. Linguaggio che appunto si chiama WebAssembly e che permette per esempio a un'applicazione di facial recognition di girare al posto di 3 frame al secondo che è la performance data dalla libreria che gira in javascript di girare tranquillamente a 20 frame al secondo che ha portato società come unity ed epic a riscrivere i propri motori 3d per permettere a questi di girare anche sui browser e che ha portato applicazioni molto complesse come giochi a performance di 20-30 fino a 100x di velocità. Naturalmente questa rivoluzione non è passata inosservata alle grandi corporation come Google, Microsoft, Apple e persino a Mozilla che hanno adattato i browser prodotti nelle loro case appunto per il supporto a questo nuovo linguaggio naturalmente come potete immaginare anche gli hacker non sono stati dietro a guardare e quindi c'è stato l'inizio di sviluppo anche di qualche malware e più delle volte sono dei miner che girano appunto nel browser alcuni di questi quelli che mi vengono in mente sono coive e cryptoloot finché diciamo la v3c community ha definito lo standard del web assembly quindi ha formalizzato, ha portato questo nuovo linguaggio nel mondo del web. Questo nuovo linguaggio che permette la realizzazione di moduli in linguaggio nativo, in linguaggio comunque abbastanza vicino al target di compilazione avvicinandosi alle performance e programmi in assembly o molto vicino al linguaggio macchina e che ha aperto l'orizzonte dello sviluppo a mondi che prima erano preclusi. Faccio un esempio. Se io fossi un Netflix, la situazione, o uno Spotify, e volessi sviluppare il mio formato video fino a qualche anno fa, questo era impossibile. Ma se io lo volessi fare oggi potrei tranquillamente farlo, perché potrei sviluppare il mio codec in C o in C++, compilarlo in WebAssembly e farlo girare il browser senza dover aspettare che le case che realizzano i browser sviluppino i moduli per far girare appunto il mio codice. Prima ho detto scrivere il codice in c++. In realtà uno dei vantaggi appunto del WebAssembly è che alla fine è un target di compilazione. Quindi in realtà il codice