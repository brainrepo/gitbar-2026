Siamo noi che nonostante il deploy fallito, la CIA rossa, il business incazzato, ci troviamo al Gitbar e davanti a una birra tutto ci sembra un po' meno grave. Bene e benvenuti su Gitbar, nuova settimana e nuovo episodio qua nel nostro bar degli sviluppatori. Non sono solo con me c'è Luca, ciao Luca! Ciao, bene bene tutto bene finalmente qui, era un po' che mancavo in questi anni. sì erano un po' di episodi che ti sei dato alla macchia eh sì sì in realtà ero ubriaco da qualche parte qui nel barro ma adesso sono sobrio adesso sei sobrio e tra l'altro oggi abbiamo un ospite fighissimo io io sto fremendo sto fremendo non vedo l'ora di farlo entrare anche perché l'ho intercettato a Code Emotion durante un discorso fighissimo tra il nostro ospite Paolo Salvatore Sanfilippo e Paolo si parlava di evoluzione di linguaggi di programmazione, ho detto fermi tutti tu devi per forza, ti prego venire a Gitbar, c'è una pinta di birra pronta per te ti supplico e così è stato. Però prima di presentare il nostro ospite il mio ruolo un po' noioso è quello di ricordarvi i nostri contatti info@gitbar.it @brainrepo su Twitter oppure il famoso e famigerato ormai gruppo telegram lo potete cercare cercando "Gitbar podcast" vedrete il nostro logo giallo e siamo a 1500 iscritti o poco più. Sì una piccola nota in genere davamo una volta una birra gratis a chi entrava virtuale si intende. Adesso visto il grande numero di utenti per salvaguardare anche la privacy degli utenti abbiamo messo alcuni settaggi di privacy per cui non veniamo più avvisati quando qualcuno entra e ogni tanto qualche birra scappa, quindi se volete entrare nella gruppo Telegram entrate tranquillamente, se salutate e date il buongiorno, il buongiorno con una rigorosa gif di caffè avrete una birra, la prima birra in omaggio da noi. Detto questo...entrate e salutate. Detto questo io ci tengo a dire rapidamente che abbiamo anche un canale YouTube da poco, quindi se non vi siete ancora iscritti e cliccato sul campanaccio fatelo pure per rimanere aggiornati e basta dai è arrivato il momento di partire. Ehi, anche questa puntata è registrata in collaborazione con FiscoZen, esattamente tutto quello che serve quando si ha partita IVA. Oggi abbiamo con noi Paolo Caressa, un matematico di studi, nel senso che si è laureato in matematica, ha fatto un dottorato in matematica, ma un informatico nell'anima che però ha shiftato di ruolo e si è concentrato la sua attenzione verso la qualità del software. Paolo, ho detto bene? Eh sì, hai detto benissimo. Insomma, come dico sempre ai miei colleghi, ho vissuto varie vite. Mi capita spesso di dire "in un'altra vita ho fatto questa cosa". guarda voglio partire da te con una domanda, io vengo dai late anni 90, primi anni 2000 ed esistevano ancora ed erano le fanzine io so che tu contribuivi a una fanzine di fantascienza e la mia domanda che esula un po' da quello di cui andremo a parlare oggi è Ieri c'erano le fanzine, oggi ci sono i blog, le newsletter e via dicendo. Secondo te cosa è cambiato sul contenuto? Sul contenuto è cambiato molto, perché verrebbe da dire che una fanzine pubblicava racconti, editoriali pubblicava articoli su carta, stampati in maniera più o meno fortunosa e poi distribuiti neanche se si sa bene come. Oggi uno può farsi un blog, un sito, con un wordpress addirittura, in maniera molto semplice, nel quale popolare gli stessi contenuti. Però vi assicuro che scrivere per il digitale e scrivere invece per la carta è diverso. Per cui i contenuti sono cambiati perché devono essere più appealing, i naviganti, coloro che si imbattono nel sito, a meno che non lo vanno a cercare espressamente, devono essere attratti. Quindi devi avere una modalità diversa di narrazione, devi inserire figure, devi inserire tutta una serie di elementi multimediali che nell'epoca delle fanzine, che una volta erano ciclostilate, ai tempi miei già c'erano le stampanti, quindi la stampavamo però era in bianco e nero, la rilegavamo alla buona e poi poi la distribuivamo a chi caritatevolmente ce la prendeva, era tutto un altro mondo. Poi, noi eravamo una fanzine di fantascienza, avevamo avuto anche un certo seguito, ci chiamavamo la rivista di fantascienza in maniera molto altisonante, però eravamo una fanzine di universitari e altre persone che contribuivano con i loro racconti. Peraltro il primo articolo di intelligenza artificiale io l'ho scritto per quella fanzine, figuratevi, nel 1992, lo so, insomma. Quindi ognuno ci scriveva quello che voleva, in realtà. Era una cosa molto libera, molto divertente e anche forse un po' goliardica. Oggi è più facile farlo, perché puoi mettere contenuti visivi, puoi mettere contenuti audio, come stiamo facendo adesso, puoi fare tante cose, c'è lo smartphone, tutti quanti siamo connessi, quindi è molto più facile. Però chiaramente devi avere un linguaggio diverso per attrarre le persone hanno meno tempo perché c'è tantissima offerta e quindi tu devi catturare l'attenzione di chi sta navigando il sito, il blog o quello che è. Quindi è parecchio cambiato secondo me. LM: sì, mi viene in mente mentre parlavi del fatto della consegna della fanzine come azione pratica e quindi come elemento esperienziale. Io sono per strada, trovo Paolo che sta distribuendo sta distribuendo fuori dall'università la fanzine io lo prendo già prendere quella fanzine era parte dell'esperienza di fruizione del contenuto già quell'azione era contenuto di per sé cosa che secondo me non voglio fare il boomer anche se lo sono oggi un po' si è smaterializzata e ha perso un po' da pila un po' di magia no? perlomeno per me che vengo probabilmente da un'altra generazione. Diciamo che si perdeva anche un mucchio di tempo. Si può fare questo paragone. È un po' la differenza tra pubblicarsi un libro su un sito di libri elettronici e pubblicarsi fisicamente un libro, andarlo a farsene fare n copie in una copisteria e poi andare da una libreria a dire "me le prendete" e quelle te ne prendono due o tre. Noi andavamo alle dicole, andavamo nelle librerie specializzate di fantascienza, per cui ci prendevano due o tre copie e poi se le vendevano, ci davano qualcosa, altrimenti insomma era veramente un'avventura. Oggi quell'aspetto lì non c'è, però è vero che intercettavamo un pubblico di persone veramente interessate e poi era estremamente divertente fare tutto questo. assolutamente sì. Oggi nel gruppo si parlava di podcasting, di spotify, di queste cose qua e credimi quello che tu hai appena raccontato con la fanzine è un po' quello che noi oggi facciamo col podcast e col feed rss nel podcast. Quindi l'idea di avere una... io vengo dal mondo delle radio, quindi una radio libera con cui parlare senza dover dare risposte a un'entità superiore o a uno che ti osta, perché sei autonomo, lo stai facendo in piena libertà e te ne prendi anche le responsabilità e quindi un po' c'è questa magia di I love Radio Rock nel podcasting e qua ci ho trovato un anello di connessione. Però ritornando proprio al tuo percorso formativo, tu vieni dalla matematica e dalla matematica pura e approdi poi all'informatica e allo sviluppo software. È normale che la mia domanda standard è cosa ti sei portato appresso da quell'esperienza universitaria e di dottorato in matematica a il mondo un po' più pratico, più industriale, non posso dire più tangibile, perché comunque rimane un mondo abbastanza etereo, però un po' più legato a quella concretezza che il deve funzionare, il deve far muovere gli ingranaggi. Diciamo che il mio percorso è ancora più tortuoso, perché io in realtà mi sono iscritto a matematica nel lontano 1988, moltissimi ascoltatori non erano ancora nati, a quell'epoca, questo mi dà un po' i brividi, non era accaduto neanche il muro di Berlino, tanto per dirne una, mi sono iscritto nel 1988 perché a Roma non c'era la facoltà di informatica, non c'era ancora scienza dell'informazione e io volevo fare informatica in realtà, perché dall'età di 12 anni, con il mio computer da 48k, il mitico ZX Spectrum della Sinclair. Io programmavo e ho programmato negli anni del liceo tantissimo, in BASIC, poi in linguaggio macchina, poi in FORT, poi in Pascal. Insomma, avevo approfondito già la programmazione e avevo soprattutto scoperto il piacere, la lussuria, proprio la goduria della programmazione. Quindi mi interessava proseguirlo, però non c'era a Roma. Se uno voleva iscriversi dove fare o ingegneria, elettronica o matematica o fisica. Io che ero più incline un po' al pensiero filosofico sono andato verso la matematica e poi sono rimasto fulgorato sulla via di Damasco perché la matematica si fa all'università di un livello qualitativamente diverso rispetto a quella che fa al liceo. Ho scoperto l'algebra, la topologia, una serie di cose meravigliose delle quali ignoravo l'esistenza e quindi stato avviluppato da questo mondo della matematica pura e pur continuando a coltivare l'interesse per la programmazione, ho passato diversi anni a fare solo quello, anche perché sono studi che per farli bene sono totalizzanti. Quindi ho fatto il dottorato e poi ho fatto per qualche anno il ricercatore precario, finché non ho avuto la possibilità, per caso, insomma, un'azienda mi ha chiesto una consulenza perché avevano un problema di intelligenza artificiale nel 2001, un problema di classificazione dei testi. Io gli avevo trovato dei paper, insomma, molto semplici dal punto di vista matematico, che consentivano di fare questa classificazione e mi sono offerto anche di fargli proprio la libreria. E scrissi in C questo programma di produzione per cui fu pagato moltissimo, più di quanto mi davano fare le mie ricerche precarie all'università. Quindi dopo un po' continuato a fare consulenze, ho abbandonato il dolce talamo della matematica pura per concedermi all'alcova un pochino più, se volete, lussuriosa e frenetica dell'industria. Però è stato bene così. E quindi mi porto appresso, il mio cuore è diviso in due. Una parte, sono un matematico puro, interessato alla logica, alla topologia, a queste cose totalmente astratte, dall'altra sono un informatico con una particolare predilezione per la programmazione. Poi questi due aspetti, dal punto di vista teorico, si fondano perché le ricerche di informatica teorica oggi sono molto matematiche. Ci sono, per esempio, sistemi di certificazione dei teoremi, i linguaggi come lean che possono essere utilizzati per fare questo derivano dai linguaggi logici, c'è tutto un filone molto matematico e logico di studi nell'informatica teorica, che poi ha qualche ricaduta anche su sui problemi pratici, perché per esempio la certificazione dei programmi, la prova della correttessa dei programmi, è utile in certi contesti dove tu c'è delle applicazioni mission critical, oppure se devi progettare un chip, un processore eccetera, queste tecniche vengono effettivamente utilizzate. Quindi sono un uomo diviso a metà, insomma, un giano bifronte fra la matematica e la programmazione, in generale l'informatica, ma va bene, mi piace così. LM: che poi mi piacerebbe sapere la tua definizione di "matematicamente semplice", che quando l'hai detto mi immaginavo… dopo un dottorato forse qualcosa… LM: la matematica è una disciplina iniziatica. Io mi ricordo distintamente quando facevo fatica a seguire certi concetti che ora mi sono facili. È un cammino in cui tu, faticosamente, come in una setta segreta, accedi piano piano a dei livelli sempre più alti di iniziazione. E non si finisce mai, ovviamente. Poi ci sono quelli che hanno il talento naturale e ci arrivano subito. Ma tu invece, le persone come me che non hanno un talento naturale per la matematica, devono usare l'intelligenza per farla. Quindi insomma si richiede fatica. Però ecco, la matematica semplice è quella che tu hai digerito e con la quale sei familiare. Quindi è un concetto che dipende da ciascuno di noi. Per qualcuno sono le addizioni, per altri è la trasformata di Fourier. La matematica semplice insomma dipende dalle proprie inclinazioni. Sì, proprio con Paolo che saluto, parlavamo l'altro giorno di trasformate di furie, oh che bello. Io, fortemente limitato, sono matematica, sono stati tra i miei esami più tortuosi, più faticanti, più faticosi che abbia mai fatto. Però tu hai parlato di intelligenza artificiale negli anni 90. E qua adesso, parlato di problema di classificazione, mi ha incuriosito. Cioè, negli anni 90, quando si parlava di classificazione, si parlava di k-means e di quel tipo di algoritmi o c'era qualcos'altro? Allora diciamo, negli anni 90, all'inizio degli anni 90, quando c'era stato il secondo inverno dell'intelligenza artificiale, era tramontata l'epoca dei sistemi esperti, quindi dell'intelligenza artificiale fatta con metodi logico-simbolici. Se voi prendete un libro di intelligenza artificiale dell'epoca, per esempio c'è un libro famoso di Niels Nilsson, che all'epoca era un classico, in tutte le università si studiava, e lo aprite oggi, non trovate una sola cosa che riguarda l'intelligenza artificiale come si studia oggi. Perché c'è stata proprio una rivoluzione nel frattempo. Dai metodi logico combinatori, per cui la ricerca nell'albero degli stati, tutte quelle cose lì, si è passati ai metodi statistici numerici. Le reti neurali, in particolare l'algoritmo di backpropagation, che è stato inventato negli anni '80 ma che si è affermato all'inizio degli anni '90, hanno determinato questa transizione. Io, in particolare, nel 2001 avevo utilizzato già tecniche di questo tipo per fare la classificazione di documenti. Avevo fatto anche un prototipo basato sul famoso teorema di Bayes, il celebre algoritmo Naive Bayes, che adesso sta nel primo capitolo di ogni libro "Intelligenza Artificiale", che non è un'intelligenza artificiale basata su reti neurali complesse, ma sostanzialmente un sistema lineare equivalente a una regressione, molto furbo, che utilizza una regola probabilistica e con la quale si riusciva a fare classificazioni di documenti, certo non con la precisione accuratezza con cui oggi una rete neurale profonda riesce a farlo. Però, insomma, era l'inizio di questo mondo che vediamo adesso. Poi la vera rivoluzione è arrivata dopo il 2000, con il deep learning, ma quella è un'altra storia. LM: Mauro, stai parlando ma nessuno ti sente. Ho appena dimostrato di essere un'idiota, non accendendo il microfono. Dicevo hai parlato prima di linguaggi di programmazione e io so perché ci siamo già parlati che tu sei un grande appassionato dei linguaggi e allora mi viene da chiederti possiamo forse se dico una castroneria ti prego correggimi proviamo a immaginare e la matematica almeno definirla parzialmente, perché magari questa definizione non la può comprendere tutta, come un modello per rappresentare una certa cosa, ok? Un modello per rappresentare del pensiero, ok? Partiamo da questo. È il linguaggio di programmazione come un modello per rappresentare il pensiero. Esistono dei ponti tra questi due modelli? DL: diciamo che i linguaggi di programmazione che ci sono oggi, che sono dei mostri, dei viatani giganteschi rispetto ai linguaggi di programmazione dell'epoca in cui ho cominciato io, figuratevi che io programmavo in BASIC e in PASCAL, che sono linguaggi che possono essere descritti in un libro di 100 pagine. Java, C#, Python, con tutte le loro librerie non può, richiedono migliaia di pagine probabilmente, se nessuno stamperebbe un libro in cui spiega tutte le librerie di Python. Vai sul sito ufficiale e te le studi. E nessuno le conosce tutte ovviamente. Quindi però i linguaggi, anche quelli di oggi, sono assemblee, sono diciamo conglomerati di modelli linguistici di programmazione che esistevano già in passato. ci sono due principali fonti per i linguaggi di programmazione che precedono l'invenzione del computer. Il primo sono le macchine di Turing. Turing, nel 1936, sembra strano perché faccio una parentesi, ma lo sappiamo tutti, siamo fra sviluppatori, però insomma conviene sempre ripeterla questa cosa. Gli algoritmi esistono da millenni. Negli elementi di Euclide si trovano degli algoritmi. I babbellionesi avevano degli algoritmi per fare calcoli e l'addizione in colonna esiste da secoli. Però il concetto di algoritmo è stato capito solo nel 1936, per la prima volta da due persone, che sono Alan Turing, che ha definito le macchine di Turing che sono una macchina stratta puramente matematica, il ponte a cui accennavi tu, e Alonzo Church, che era un logico statunitense a Princeton, dal quale Turing era andato a fare la tesi di dottorato. Alonso Scerci ha inventato il lambda calcolo. Quando noi oggi parliamo delle lambda funzioni stiamo parlando di un concetto inventato negli anni '30. Il lambda calcolo è un formalismo per esprimere le funzioni. Il lambda calcolo ha dato origine al LISP, al linguaggio di programmazione LISP, a fine degli anni '50 e a tutto un filone di programmazione funzionale che è un po' considerato esotico dagli altri programmatori, ma che adesso è prepotentemente presente in tutti i linguaggi. JavaScript è un linguaggio fin dall'inizio che ha elementi funzionali, puoi definire le chiusure in JavaScript. Tutti gli altri linguaggi oggi, Java, C#, etc., Python, hanno accolto il paradigma funzionale fra i tanti paradigmi che offrono, quello procedurale, quello oggetti, eccetera. Però quello viene da Church. Invece Turing ha ha proposto un modello operativo di macchina che ha dato origine, in qualche modo, se vogliamo, era una sorta di linguaggio macchina stratto. Quelli che hanno inventato i primi linguaggi di programmazione negli anni '40 e '50, quello avevano presente. Quindi questi modelli puramente matematici, le macchine di Turing, il lambda calcolo di Church, poi ce ne sono anche altri equivalenti di modelli della calcolabilità, le macchine a registri per esempio, che sono molto simili a dei processori. Sono il ponte che dicevi tu, sono dei modelli astratti e generali di calcolo che poi possono essere trasformati, concretizzati, reificati sui computer. Il computer è una macchina di Turing con una memoria limitata. La macchina di Turing ha una memoria virtualmente infinita ed esegue una serie di operazioni deterministiche pre-programmate. Un computer ha una memoria, che non è infinita ma è molto grande, e segue delle operazioni pre-programmate, cioè come se avesse un BIOS, e poi uno può scrivere dei programmi per quella macchina per eseguirne di altri, esattamente come si fa con le macchine di Turing. Quindi il modello del linguaggio di programmazione è figlio della teoria della calcolabilità fatta da questi due matematici negli anni '30. e quello è il legame che li unisce. Per i primi 20-30 anni quelli che si occupavano di linguaggi di programmazione erano matematici, logici o fisici. Se andate a leggere il Code Emotion, io ho presentato un talk nel quale riesumavo un articolo del 1963 di Peter Landin, nel quale lui definisce i concetti di base dei linguaggi funzionali utilizzando il formalismo matematico di Church e di quelli che sono venuti dopo. Quindi c'era questo legame molto forte all'inizio. Poi l'informatica l'hanno cominciato a fare anche gli ingegneri, anche i non scienziati, fra virgolette, anche le persone non STEM, come diremmo oggi, e quindi si è in qualche modo estesa eccetera eccetera. Però alla sua base ci sono questi modelli che sono modelli puramente matematici, cioè inventati prima che fossero stati inventati i computer. A questo punto mi viene una domanda, pensavo al modello di programmazione, quindi abbiamo parlato dell'handa calco, abbiamo parlato della macchina di Turing, cos'è secondo te che ha fatto sì, che ha promosso un modello puramente teorico invece un paradigma di programmazione strettamente pratico. Qual è il percorso che ha accompagnato questa evoluzione? Diciamo che i primi linguaggi di programmazione per computer sono stati molto influenzati anche da come erano fatti i computer dell'epoca. Quindi la tecnologia, l'hardware, era profondamente influenzato, e lo fa tuttora. Perché pensate ai linguaggi, non lo so, il grande successo di Java, quando è uscito fuori 30 anni fa, perché Java è uscito fuori nei primi anni 90, era legato alla sua capacità di riuscire a programmare su internet. Non soltanto potevi fare le famose applet, famigerate applet, che forse qualcuno si ricorda e che per fortuna sono un ricordo del passato. Era il vero male. Però è stato il primo di una serie di linguaggi che hanno avuto molto seguito e successo perché ti consentivano di sfruttare una nuova tecnologia fisica, cioè la connessione e il web soprattutto. Allo stesso modo, se voi immaginate il FORTRAN, il più antico dei linguaggi di programmazione che ancora oggi esiste, è uscita quest'anno, nel 2023, la nuova versione del Fortran. Ormai anche lui ha un mastodonte che dentro contiene tutto, oggetti, qualunque cosa. Però la prima versione del Fortran, uscita credo nel 1954, non ha un'istruzione print per stampare sullo schermo, perché non c'erano gli schermi. A quell'epoca tu col computer comunicavi con le schede perforate e lui ti stampava da qualche parte il risultato. Quindi l'evoluzione, diciamo, e quindi il linguaggio Fortran a quell'epoca era concepito per quel tipo di computer. Per cui, diciamo, la concretezza della strazione dei modelli matematici viene quando tu vuoi effettivamente programmare o implementare un linguaggio su un computer fisico e quindi ti devi porre tutta una serie di problemi. Le performance, la gestione della memoria, l'input output, eccetera. A quel punto il linguaggio ti si concretizza per forza. Per cui, se tu lo inventavi negli anni 50, dovevi mettergli delle istruzioni che consentissero di leggere dalle schede perforate. Se lo programmi oggi, devi assolutamente includere delle librerie per trattare le sessioni http, oppure per utilizzare widget grafici in una pagina web, eccetera eccetera. Per cui le tecnologie hardware, diciamo in senso lato hardware, quindi la struttura anche delle interfacce dei computer, determinano poi e si riverberano su tutti i dettagli che un linguaggio di programmazione deve avere per poter essere utilizzabile in pratica. Perché è chiaro che la macchina di Turing è una cosa bellissima e potenzialmente riesce a programmare qualunque algoritmo, ma solo un pazzo costruirebbe un computer fatto con una macchina di Turing. Oggi abbiamo possibilità di avere appunto lo schermo, internet, usb, qualunque cosa e quindi i nostri linguaggi devono consentire di interfacciarsi con tutti questi dispositivi all'interno del computer o del cellulare o di dove li vogliamo deployare. Sì, a Code in Motion ricordo nella nostra chiacchierata così in un angolino, come spesso spesso succedono le cose più belle. Ricordo che abbiamo parlato, abbiamo provato a capire la differenza e il perché si crea una differenza tra linguaggi general purpose e linguaggi un po' più, let's say, accademici. Secondo te cosa rende un linguaggio accademico e cosa rende invece un linguaggio general purpose e di adozione di massa, se così possiamo definirla? Diciamo che il linguaggio accademico non so quanto esista più veramente, non so quanto sia facile oggi per creare un linguaggio "accademico", però i linguaggi accademici, pensiamo per esempio al Pascal, il Pascal è un linguaggio adesso forse gli ascoltatori più più giovani non sanno neanche cosa sia, ma insomma un linguaggio creato nel 1971 abbastanza innovativo rispetto ai linguaggi che c'erano all'epoca perché alla fine degli anni 60 si era capito che tantissimo software era buggato, il software era in crisi perché se ne produceva tanto ma la qualità era bassissima e hanno cominciato a capire che la bassa qualità era legata alla poca espressività dei linguaggi usati. In particolare c'erano tantissime istruzioni per poter esplicitamente saltare da una riga all'altra del programma, i famosi "go-to". Una corrente di pensiero, la cosiddetta programmazione strutturata, sosteneva che bisognava utilizzare pochissime strutture di controllo, "if", "then", "else", "why", "do", quelle che ci sono ancora oggi, e cercare di evitare i "go-to". Il Pasquale è stato concepito apposta con questo in mente. è un linguaggio fabbricato nell'accademia per motivi didattici, per insegnare una buona programmazione a chi seguiva l'università e che poi è filtrato anche all'esterno, dove però si è dovuto arricchire di elementi. Per esempio l'input output era molto trascurato. Brian Kernighan, uno dei grandi guru dell'informatica, lo conosciamo per i suoi libri. Ha scritto il libro su C, ha scritto il libro su Unix, ha scritto il bellissimo libro "The Practice of Programming" e "La pratica della programmazione". Lo consiglio a tutti, un libro bellissimo sulla programmazione. Lui ha scritto un articolo negli anni 70 dicendo "perché non mi piace il Pascal". E che sono i motivi? Leggendo quell'articolo capisci perché il C è fatto come è fatto. Perché il Pascal era un linguaggio creato a tavolino, in un certo senso, molto astratto, molto teorico, sicuramente che ti imponeva delle buone pratiche di programmazione, ma che se poi dovevi fare un database, leggere dei file, insomma fare una serie di cose, non rendeva disponibile. Quindi bisognava creare o programmarsi delle librerie per fare questo, e il linguaggio non le prevedeva a priori. Mentre invece il C, che è nato nello stesso anno del Pascal nel 71, che è nato anche come linguaggio per rendere portabile Unix. Il chip aveva delle librerie di base, di input e output, che ci sono ancora quelle oggi, che tu puoi usare ancora oggi nel C++. Il famoso standard in, standard out, standard R, F open, una serie di nomi di comandi che oggi magari hanno un significato un po' più generale, che trovi in linguaggi come PHP, come java eccetera sono stati inventati a quell'epoca proprio perché non si voleva fare un linguaggio accademico ma un linguaggio immediatamente utilizzabile anche nell'industria. Quindi, in qualche modo, la differenza fra linguaggio accademico e quello che nasce per motivi pratici è che quest'ultimo deve sicuramente consentire di potersi interfacciare con tutti gli apparati che il computer ha a disposizione. Mentre invece nel linguaggio accademico ci si concentra sulla parte più algoritmica. Invento il linguaggio per programmare eventi concorrenti. Perfetto, bellissimo. Poi però su che tipo di macchine lo posso implementare? Mi serve un processore con più core, una macchina con più processori? E quindi si pongono poi nella pratica una serie di questioni che incidono sul linguaggio, lo trasformano o dalle quali si evince che il linguaggio non è adatto e che bisogna crearne un altro. Uno dei problemi, uno dei motivi per cui linguaggi funzionali, che invece secondo me sono molto semplici ed espressivi, hanno fatto fatica a trovare spazio nel mondo dell'industria, anche se in certi ambiti si usano. E' proprio questo, che sono linguaggi molto accademici, molto teorici, che poi si devono in qualche modo sporcare le mani quando lo vai a effettivamente a voler implementare su una macchina. Quando vuoi costruire un compilatore per quel linguaggio su un computer piuttosto che un altro, devi prendere in considerazione delle cose che chi ha progettato quel linguaggio non ha pensato. Questa è un po' forse la differenza. E' anche il motivo per cui oggi i linguaggi di programmazione sono così enormi e multiformi, offrono tutti i tipi di paradigmi anche perché devono attrarre il pubblico. Se java non offrisse gli stream e le lambda, che sono bellissimi in java, un'invenzione recente di quel linguaggio, non si potrebbero fare alcune cose fatte col flavor funzionale e quindi magari gli si userebbe il C#, il suo grande rivale. Per cui è chiaro che oggi i linguaggi tendono a fagocitare tutto e a offrire tutti i possibili strumenti per fare qualunque cosa. E da questo punto di vista sono tutti equivalenti. Quando invece, che ne so, negli anni '60 c'era il Fortran adatto al calcolo scientifico, il COBOL adatto alle applicazioni gestionali, e così via. C'era lo Snowball, un linguaggio incredibile che era basato su pattern matching, c'era il lisp. Ogni uno aveva una caratteristica propria, erano molto distinguibili fra loro. Oggi si fa fatica per un novizio a distinguere il codice java da quello c#, per esempio. Per cui questo è un po' come si è evoluta l'industria. Insomma, oggi c'è molta più industria, c'è molta più richiesta, molta più offerta, molta più domanda e un programmatore deve con un solo linguaggio riuscire a fare tutto, in qualche modo. Perché è oneroso imparare un linguaggio di programmazione bene, oggi, bene, impararlo bene intendo. Imparare Java non è facile, imparare il Pascal sì, perché il libro che descrive il Pascal è di 50-70 pagine. No, no, no, ma mi hai incuriosito prima, hai detto che 50-60 anni fa, non lo so, c'era tanto software buggato e allora hanno adattato il linguaggio di programmazione per renderlo più... per fare modo di creare software più robusto. Mi viene in mente qualcosa deve essere andato storto nel frattempo, perché abbiamo ancora tantissimo software bugato o scritto male o insomma non bello, o che alla peggio non fa quello che promette di fare. Però abbiamo anche ovviamente tanto tanto software di qualità, quindi non so se la proporzione alla fine rimane costante nel tempo, oppure qualcosa effettivamente cambiato? DL: diciamo che l'epoca a cui mi riferisco io alla fine degli anni '60 è l'epoca in cui poi nasce l'ingegneria del software, perché il problema non è solo il linguaggio di programmazione, il problema è la metodologia. Era un'epoca in cui ancora si pensava che il grosso dell'attività in un progetto informatico fosse codificare, fosse scrivere il codice, quando oggi sappiamo che non è così. Il grosso è fare i test, i test d'unità, i test integrazione, il collaudo utente, il test finale. Oggi gran parte dell'effort in un progetto informatico, il cui scopo è produrre un programma, non è la codifica ma nemmeno la progettazione, è l'analisi e il test. Questo è stato capito negli anni '60, però si dava spesso la colpa anche a questi linguaggi nei quali era facile scrivere il famoso spaghetti code, un codice difficilissimo da seguire. Uno dei grandi della computer science, adesso non mi ricordo se era Dijkstra o Wirth, uno di loro ha detto che i programmi per computer non dovrebbero essere fatti per essere eseguiti dalle macchine, ma per essere letti da altri programmatori. Quindi in base a questo si era affermata la consapevolezza che la manutenzione del codice richiede la semplicità di seguire su pezzo di carta, di fare a mente l'analisi statica del programma. Per cui i linguaggi di programmazione hanno cominciato a fornire gli strumenti per farlo. Vi faccio un esempio. Io iniziero a programmare in BASIC. BASIC è un linguaggio incredibile, perché il BASIC originario degli anni '60 aveva 10 istruzioni. Quello in due giorni imparavi a programmare in Basic. Infatti era un linguaggio progettato espressamente per non tecnici, per studenti di facoltà umanistiche, sociologi, antropologi eccetera. Però il Basic aveva pochissime istruzioni e aveva una istruzione IF che ti consentiva di testare una condizione. Se la condizione era vera saltavi in un altro punto del programma, altrimenti continuavi. Non c'era il While, non c'era il If-Then-Else, non c'erano le strutture di controllo che oggi troviamo in tutti i linguaggi. Pensare cosa vuol dire scrivere un programma che ha tanti loop annidati fatti in quel modo? È difficile seguirlo. Quindi in qualche modo si era capito questo, che il linguaggio può indurre delle buone pratiche, però il linguaggio e la programmazione non esauriscono lo scopo dell'ambito di un progetto software. Questo per fortuna oggi ce l'abbiamo ben presente. C'è la documentazione, c'è tutta una serie di cose fondamentali che chiaramente i programmatori risultano fastidiosi, noiose, non ci va di farle, ma perché devo scrivere i commenti, perché devo fare questo o quello? A parte che se uno scrive i commenti in un certo modo poi può utilizzare uno strumento che dai commenti ti produce la documentazione. Io usavo Doxygen nel 2005, producevo la documentazione dei miei programmi in C and Fortran automaticamente, usando una certa disciplina nello scriverli. Però ecco, è proprio un discorso di metodo. Quindi la grossa crisi del software a fine anni '60 era dovuta all'anarchia che imperava. Probabilmente la crisi del software che ha continuato a esistere è perché si pensava che, introducendo nuovi linguaggi di programmazione, tutti imparassero a programmare. Questo è come dire, no? Supponiamo di dire "la maggior parte delle persone sono stupide, allora inventiamo un linguaggio, una lingua più semplice in cui tutti si possano esprimere ed essere intelligenti. Non funziona così. Io posso inventare una lingua, per esempio c'è l'inglese semplificato, il simple English, che è un inglese con poche parole, ma non è che se io parlo l'inglese divento più intelligente o dico cose più intelligenti. Quindi non è solo il linguaggio quello che crea il problema, del bug o del non fare bene un programma, è tutto quello che c'è intorno, è un problema più ampio insomma. Sì mi chiedo se l'esplosione degli ecosistemi, quindi pacchetti a corredo, in qualche modo abbiano non solo dato potenza ai linguaggi, ma anche in qualche modo essere diventati la discriminante per l'adozione di un linguaggio, perché ormai salvo casi specifici magari un po' più orientati c'è una generale convergenza verso il linguaggio. Adesso magari non citiamo Askel che è uno dei più radicali nell'approccio, però se io penso alle funzioni come i primi cittadini o penso a un'altra cosa che si parla poco. Non so se vi ricordate si chiamava AspectJ, qualcosa del genere, un linguaggio per la programmazione orientata agli aspetti. Ormai anche questo paradigma può essere fatto con buona parte dei linguaggi perché un po' tutti i linguaggi supportano la metà programmazione, un po' tutti i linguaggi bene o male, talvolta molto male, supportano gli oggetti e alla fine un po' tutti i paradigmi possono essere fatti con un po' tutti i linguaggi salvo casi specifici. A questo punto la discriminante diventa la Dev Experience è il pacchetto a corredo, mi viene in mente Python. Python è diventato famoso non tanto per il linguaggio a sé stante, almeno nella seconda gioventù di Python, che è quella che stiamo vivendo oggi, è diventato famoso non per la potenza del linguaggio, la velocità, l'espressività, ma per l'ecosistema che gira attorno. Mi viene in mente tutta la parte dei big data, da PySpark a Pandas a tutto il mondo mondo del machine learning, cioè fondamentalmente quello che ha reso in auge il linguaggio non è più tanto il linguaggio. Ma se io ripenso al concetto, scusa Paolo perché secondo me sta qua il mechanism, se io ripenso al concetto di linguaggio come strumento per esprimere pensiero, l'idea di discriminare un linguaggio per il suo ecosistema mi stride dannatamente. Se facciamo il caso di Python, per esempio, è un caso interessante perché lui è stato inventato da Rossum nel 92, credo, perché Rossum aveva bisogno di un linguaggio di script, come poteva essere Perl, come Perl è un po' esotico, diciamo, come sintassi e tutto, come poteva essere il Perl, come era Bash, eccetera. E quindi lui ha implementato Python all'inizio con quello scopo. Infatti nel suo progetto il linguaggio è nato non per essere veloce, ma per essere facile, diciamo, facile da usare, facile da scrivere, facile da interpretare. Poi, appunto, la seconda giovinezza a cui fai riferimento te è perché a un certo punto la comunità, o una comunità o più comunità, che usavano questo linguaggio lo hanno utilizzato per fare delle cose hanno prodotto. E quindi il linguaggio, essendo aperto, che è la caratteristica fondamentale che devono avere oggi tutti i linguaggi, essendo aperto, ha seguito la moda, se voglio, comunque il driver delle community. Per cui a un certo punto Python è esploso come linguaggio dell'intelligenza artificiale. Perché? Perché aveva fornito le librerie, non scordiamoci che google per esempio, quando ha fatto uscire tensorflow, che in qualche modo è la libreria che sta alla base di tutte le librerie che ci hanno costruito, più semplici, di intelligenza artificiale, e l'ha resa disponibile per python perché loro lo utilizzavano e questo ha reso un servizio al linguaggio. Il motivo per cui mi viene in mente anche l'esempio del c++. C'è stato un momento in cui il c++ era un linguaggio estremamente in voga, essendo molto difficile, molto complesso, molto stratificato, era in voga perché ci avevi pronta la libreria standard, la STL del C++, nella quale ti trovavi tutto quello che ti serviva per fare le cose tramite template, eccetera. Quindi, in qualche modo, quello che guida il successo di un linguaggio in un certo campo è innanzitutto la community di quelli che lo usano. per le lingue umane. La lingua non esiste se non ha una comunità di parlanti. Sono quelli che parlano la lingua che la rendono esistente, perché altrimenti la lingua sarebbe un oggetto immateriale. La lingua è l'uso che se ne fa. In arabo ci saranno 20 parole relativi alla sabbia, nelle lingue schimesi ce ne sono altrettante relativi alla neve. Quindi quelle lingue sono plasmate in base all'uso che ne fa la comunità che le utilizza. E forse un po' anche con i linguaggi di programmazione è la stessa cosa. Per cui Python si è orientato, per un motivo o per l'altro, forse anche per caso, a essere un linguaggio utilizzato nella prototipazione dell'intelligenza artificiale. Poi in realtà ci mandano in produzione le cose, anche se la cosa più logica sarebbe utile. È fantastico come linguaggio prototipale perché in pochissimo tempo riesce a scrivere un programma che funziona, che fa le cose, eccetera. Però ovviamente non è nato per le performance. Poi adesso hanno migliorato le sue performance con molta fatica, esattamente come Java all'inizio non era un linguaggio che doveva performare bene. Aveva pure un bug nei calcoli in virgola mobile. Quando lo programmavo io ce l'aveva ancora. Poi lo hanno fatto la just in time perché altrimenti il linguaggio non sarebbe stato appealing su una platea molto grande. Però sostanzialmente, a parte queste forzature, i linguaggi per forza dipendono in qualche senso dall'ecosistema se con quello intendiamo l'ambiente virtuale dove vive la comunità che lo usa. Il linguaggio è lo scopo per cui tu lo usi. Se a un certo punto, per qualche motivo, la comunità dei sociologi che utilizzano l'informatica, soprattutto la statistica, quindi probabilmente loro usano R, per qualche motivo scoprono che c'è una libreria in Closure, quindi un linguaggio a caso, in closure, che serve ai loro scopi e cominciano a usare closure. Chi mantiene closure, la comunità open che mantiene closure, sosterrà questo movimento, perché lo scopo del linguaggio è essere parlato da più persone possibile, e il linguaggio diventerà il linguaggio dei sociologi. In qualche modo, con una sorta di feedback, di retorazione, il linguaggio va dove chi lo parla lo conduce, in qualche modo. Chi lo parla nel caso delle lingue umane, chi lo programma nel caso dei linguaggi di programmazione. Poi è chiaro che i linguaggi general purpose in questo si propongono come buoni per tutte le stagioni. Cioè uno può scrivere "intelligenza artificiale" in Java, ci sono anche le librerie per farlo, però tutti normalmente pensano a Python. Perché? Perché si è affermata questa idea che Python è adatto all'intelligenza artificiale, quando è nato per tutt'altro scopo. LM: poi togli il tappo e trovi le librerie run-time c++ sotto, che fanno il lavoro sporco. SB: però diciamo questo un po' perché tutti questi linguaggi interpretati, che adesso poi hanno la just-in-time, però quando sono nati, Java, Python eccetera, tutti basati su macchine a stack, un'idea vecchissima anche quella. Gli stack le ha inventati Turing, per esempio, e i linguaggi a stack c'erano già negli anni '60. Peraltro, piccola parentesi storica, Il famoso Pascal, di cui parlavo prima, un linguaggio del '71 inventato dall'Accademia, è nato e implementato su una macchina stack, aveva un bytecode, non era direttamente tradotto. Quindi quel concetto lì c'era già nel 1971. Così come la programmazione a oggetti esisteva alla fine degli anni '60, è nata con il linguaggio Simula, un linguaggio inventato in Norvegia per fare simulazioni e eventi discreti. Quindi la programmazione oggetti è nata per fare simulazioni, poi si è affermata con il web, con i nuovi sistemi operativi basati su finestre dove c'erano gli eventi, per fare la programmazione di eventi. Quindi diciamo che fugge anche di mano ai creatori il paradigma di programmazione. Alla fine il linguaggio è, ripeto, l'uso che se ne fa. Quindi se un linguaggio viene fuori che è adatto per fare una certa cosa, o comunque tutti credono che lo sia, quel linguaggio diventerà il linguaggio per fare quella cosa. Poi naturalmente si attrezzerà per essere general purpose, perché ovviamente, come ripeto, oggi imparare un linguaggio di programmazione è bene e oneroso. Ciascuno di noi ha una lingua madre. Magari parli più linguaggi, ma hai una lingua madre, che è il linguaggio nel il quale tu ragioni dal punto di vista informatico. Quando devi scrivere un algoritmo, ciascuno di noi ha il linguaggio nel quale trova più facile scriverlo. Qualcuno lo scrive in Python, qualcuno scrive in R, qualcuno scrive in Java, qualcuno in C#. Quando fai le interview per ottenere lavori tecnici, specie nelle aziende Amazon, loro ti fanno un colloquio nel quale ti danno un algoritmo, ti danno dei problemi, poi ti dicono "usa il linguaggio che vuoi esprimerti. Proprio perché uno, utilizzando la propria lingua madre, punta sul concetto e non si concentra sul dettaglio linguistico. Quindi ciascuno di noi ce l'ha. A maggior ragione oggi è molto difficile imparare più linguaggi, perché sono elefantici, sono giganteschi. Io penso che nessuno al mondo conosce tutte le librerie standard di Python, perché sono migliaia. Quando ti servono, scopri che ci sono. In qualche modo vai sui forum, vai su Stack Overflow, dove ti pare. Questo è un modo nuovo di fare anche programmazione che fino a 20 anni fa, 30 anni fa, non c'era. Io appartengo ancora alla generazione di quelli che imparavano i linguaggi sui libri. Ti compravi il libro, rimediavi il compilatore, ti mettevi davanti col libro, facevi gli esercizi e piano piano cominciavi a usare il linguaggio. Oggi invece nessuno impara un linguaggio su un libro. Poi magari ti compri il libro perché vuoi approfondire delle cose, ma tanto tu sai che la versione più aggiornata del linguaggio la trovi online. Il libro in cinque anni è obsoleto. Un libro che compri oggi su python, fra cinque anni nelle cose fondamentali, va bene, saranno sempre quelle, ma molte cose cambiano o si introducono cose nuove. E quindi è cambiato anche questo, anche il modo con cui uno impara il linguaggio e lo pratica. Io direi che oggi è più difficile rispetto al passato programmare bene in un linguaggio, cioè approfondire un linguaggio nei tutti gli aspetti che ti possono servire nella tua attività di sviluppatore. Tant'è che si è diversificata anche questa attività, c'è il front end, c'è il back end, insomma. Sì sì e poi contando, guardando agli ecosistemi sono veramente smisurati. E continueranno ancora di più ad esserlo. Sì sì sì. E oggettivamente impossibile stagli dietro, proprio impossibile. Però da quello che dicevamo prima emerge un fatto importante, cioè che buona parte delle innovazioni disruptive sono comunque o risalgono comunque a tanti anni fa e quindi mi chiedo oggi cosa vedi realmente innovativo nel mondo dei linguaggi di programmazione? Ma guarda è il destino degli informatici di riscoprire cose scoperte in precedenza, diciamo io avendo anche una formazione matematica l'ho potuto appurare, facciamo un esempio semplice, Oggi l'intelligenza artificiale che c'è oggi è basata principalmente su queste benedette reti neurali. Le reti neurali profonde sono un'acquisizione recente, soprattutto per motivi tecnologici, perché negli anni '80 non c'era la memoria necessaria e le capacità di calcolo necessarie. Io ho un libro dell'80, no, dell'85, non mi ricordo, di intelligenza artificiale, dove è citato Hinton, uno dei godfather dell'intelligenza artificiale, proprio lui. Hinton, quello che tre anni fa con Benjo e LeCun è stato premiato col premio Turing, il quale parlava delle reti neurali e diceva che oggettivamente oggi, nel 1985, non sono applicabili perché le macchine non sono abbastanza performanti per farlo. La retina orale c'era già nell'85, ma vi dirò di più. La prima rete neurale è stata concepita nel '43 da McCulloch e Pitts, che hanno inventato il concetto di neurone, inteso come un insieme di numerelli ai quali si danno in input altri numeri e che produce un segnale combinando questi input con i pesi che c'è dentro. Poi è venuto il perceptrone di Rosenblatt negli anni '50, ma insomma stiamo parlando di cose molto antiche, ma la cosa ancora più sorprendente è che in realtà questi algoritmi di machine learning, la rete neurale, come fa a imparare? Impara con la cosiddetta back propagation. Ma la back propagation è basata innanzitutto su una generalizzazione della derivazione delle funzioni composte, legata a un concetto di calcolo differenziale che si studia in analisi in tutti i corsi universitari. E poi è un algoritmo di ottimizzazione, cioè tende a diminuire il tasso di errori che fa. E il metodo essenziale che sta essenzialmente a dire questo algoritmo, la discesa gradiente, è un metodo che risale ai primi dell'ottocento. Ora, non è che magari quelli che hanno inventato la backpropagation avevano presenti i lavori di Cauchy sulla discesa gradiente all'inizio dell'ottocento. Li hanno riscoperti, era giunto il momento di utilizzarli e quindi li hanno ridefiniti. Però è molto difficile scoprire idee nuove in campo scientifico, soprattutto in un campo come quello dell'informatica, che in qualche modo si basa sulla concretizzazione di idee astratte che sono già state studiate. Quindi ciò detto, la programmazione funzionale, la programmazione oggetti, la programmazione concorrente, eccetera, è stata tutta studiata nei suoi aspetti teorici essenziali ben prima di oggi. Quello che posso dire è che quello che si vede oggi è soprattutto legato di nuovo, secondo me, molto allo sviluppo delle tecnologie, che questo sì non era predecibile. Per esempio, se aveste chiesto a un informatico negli anni '50 come sarebbe stata l'informatica negli anni 2000, lui vi avrebbe raccontato di cose prodigiose che fa nel linguaggio di programmazione, ma difficilmente vi avrebbe detto che sarebbe esistito il web. il World Wide Web, che ha invece influenzato non solo la vita di tutte le persone del pianeta, perché noi lo sottovalutiamo, ma è una delle più grandi invenzioni dei nostri tempi, perché ha consentito i siti internet tutto quello che continuamente utilizziamo, e ha profondamente influenzato i linguaggi di programmazione, il modo di fare informatica, gli ecosistemi, la user experience, le aspettative degli utenti, eccetera eccetera. Quindi diciamo, secondo me, più che la teoria nella quale si continueranno a utilizzare cose magari già scoperte tempo prima dai fisici, dai matematici, dai logici, e va bene così, la frontiera secondo me è invece la tecnologia, come evolve la tecnologia dei dispositivi. Pensiamo al mondo IoT. Adesso è chiaro che se tu vuoi scrivere codice per l'IoT, siccome hai dispositivi embedded, sistemi embedded, se sei molto limitato nelle risorse, usi il C, usi MicroPython, quella roba lì. Però verrà il giorno in cui tu avrai più libertà di manovra e magari nasceranno dei linguaggi adatti per quel tipo di strumenti. Quindi, di nuovo, il driver è la tecnologia e chi la usa. Quindi, secondo me, questa è un po' la frontiera da seguire. Guardare anche le macchine dove girano i programmi. Perché il programma è in astratto, insomma, si potranno scoprire nuove tecniche, ma poi si scoprirà che erano già state scoperte e vi sa quando. Mentre invece la potenza di calcolo, la potenza di memoria, la connettività che c'è oggi è del tutto inedita, era imprevedibile 50 anni fa. E questo è quello che guida, che dà forma, secondo me non soltanto alla programmazione ma in genere a tutta l'informatica che si continua e che si continuerà a fare oggi. Io avevo il sentore sospetto, insomma, se avessi dovuto fare una previsione sarebbe stata quella di rimettere più matematica nella programmazione, perché dalla matematica è nata la programmazione, tutta la programmazione funzionale, la programmazione oggetti e noi ci vogliamo reinventare, vogliamo rendere le cose più facili, vogliamo creare dei modelli magari non matematicamente solidi perché non abbiamo le competenze, magari, però poi alla fine sempre nella matematica andiamo a finire. Quindi pensavo che nel futuro la programmazione potrà essere molto più legata, anche la programmazione quotidiana di tutti i giorni dovrà essere molto più strettamente legata alla matematica, quindi molta più programmazione funzionale, mi viene da dire funzionale perché quella che è più vicina anche come sintassi, come rappresentazione, a quella matematica. Quindi, diciamo, vedevo questo anche vedendo la crisi che forse vedo solo io, non lo so, delle nuove generazioni verso la programmazione, che forse non hanno più la passione che potevamo avere noi 30 anni fa o 40 anni fa. Adesso è tutto molto più... si, parlo da vecchio, anche io ormai. Non c'è più quella passione, è tutto molto blando. Mentre invece per scoprire le nuove cose, così come lo stiamo vivendo adesso, non puoi fare a meno di conoscere le fondamenta delle matematica. Quindi la domanda è, è soltanto una mia visione questa qua? Concludo anche il concetto, anche col fatto che con l'intelligenza artificiale adesso tante cose che possono essere fatte, tante cose chiamiamole banali, possono essere tranquillamente delegate a un copilot o strumenti di questo tipo. LM: Allora, guarda, da matematico ho presente quanto può essere ostica e noiosa la matematica a chi non piace, perché mi rendo conto che tanto quanto piace a me può non piacere a un altro, così come ci sono cose che a me non piacciono e che altri trovano interessanti e divertenti. Per cui questa idea di rendere più matematici linguaggi di programmazione sicuramente non verrà secondo me perseguita, perché li renderebbe impopolari. La programmazione tornerebbe a essere appannaggio di chi ha fatto un studi laureato in ingegneria, in matematica, in fisica, eccetera. Invece oggi tutti programmano, tutti possono programmare. Alcune promesse, come i linguaggi basati sulla grafica, non lo so io per esempio ho tentato di insegnare a mia figlia Scratch, che è divertentissimo, ma già c'erano tanti anni fa linguaggi così, non hanno attecchito più di tanto. Perché alla fine il programma, non a caso si chiama linguaggio di programmazione, ma alla fine il programma è un testo. Noi abbiamo bisogno di scrivere un test esattamente come scriveremo una lettera, un romanzo, un racconto, una poesia. Adesso poi magari un'altra volta parleremo delle analogie fra poesia e informatica che passano attraverso il concetto di complessità computazionale, di informazione eccetera. Queste le teniamo da parte, però secondo me invece l'aspetto preponderante sarà ancora di più quello linguistico e le moderne, quelle che ci sono adesso e quelle che ci saranno fra pochi mesi e anni tecnologia in dirigenza artificiale ci consentiranno di ritrovare di fare pace con il con il linguaggio perché molto spesso spesso per i neofiti il linguaggio di programmazione ha una serie di cose che tutti deve imparare senza capirle o ancora peggio come fanno molti te le copia in colli vai su stackoverflow trovi una soluzione simile al tuo problema, te la copi in colli, qualche martellata. Ci sono molti che programmano così e questo tipo di programmazione dà meno soddisfazione. Io capisco che può essere più frustrante. Per cui una serie di lavori di programmazione oggettivamente noiosi che si fanno oggi, come mettere le gette e le set nelle classi, oggi ve li fanno quasi anche gli ambienti di sviluppo. Ma quelli ce li togliamo da davanti con l'intelligenza artificiale, ci concentriamo su altre cose, ci concentriamo sui test, per esempio. Scrivere dei programmi per testare, scrivere bene i test, è una cosa diciamo che richiede molto acume, forse più che scrivere la funzione che tu vai a testare. Per cui, secondo me, si utilizzerà molto di più qualcosa di simile al linguaggio naturale, che era un sogno di nuovo perseguito negli anni '50. Perché un linguaggio che molti di voi hanno sentito nominare solo in incubi, il COBOL, però c'è ancora tantissimo codice scritto in COBOL a questo mondo che gira, sappiatelo, e ci sono programmatori COBOL che sono richiesti. Il COBOL è stato inventato negli anni 50 da Grace Hopper, una donna incredibile che poi è stata pure ammiraglio della marina navale americana, e lei ha inventato questo linguaggio perché voleva dare un linguaggio a chi si occupava di applicazioni business, gestionali. Quindi non erano né fisici né matematici ma erano contabili e gente così. Quindi il COBOL, se voi lo vedete, è molto verboso, è tutto fatto di parole, non ci sono simili. FU così che nacque l'environment division, la data division. L'environment division, data di perform, fai questo, ma se tu lo leggi sono delle frasi. Era un tentativo di rendere la programmazione analoga al parlare con il computer. Oggi lo possiamo fare. Oggi il sogno di Grace Hopper, a cui andrebbe intitolato qualche sistema di intelligenza artificiale, c'è una foto bellissima, cercatela su internet, anche per parlare degli stereotipi di genere che ci sono purtroppo nel nostro mondo tecnico, c'è una foto di Grace Hopper che sta seduta davanti a una console dove non c'è uno schermo, perché a quell'epoca non c'erano schermi in computer, piena di fili, di cose strane, vicino due programmatori chiaramente non caucasici, uno indiano e uno di colore, una foto degli anni 50 che rappresenta cos'era anche l'informatica. Noi ci pensiamo sempre al programmatore che sta lì sul sistema Unix con i popcorn e l'immagine del nerd mandata dai film. La programmazione era anche questo e loro volevano che programmare fosse come parlare con la macchina. Oggi lo possiamo fare. Non dico che siamo già in grado di utilizzare i large language model, per esempio, come linguaggi di programmazione che programmano per noi. Quindi come un compilatore in cui tu gli dici "guarda, mi serve una funzione che fa apparire una tendina sulla parte sinistra dello schermo con questo menu" e lui ti scrive il javascript che lo fa. È verosimile e vorrebbe dire che noi lo stiamo usando come un compilatore, ma d'altra parte nessuno di noi parla il linguaggio della macchina. Quando io programmo in python, non è che il mio processore poi esegue python, python viene tradotto in un bytecode che viene eseguito da un programma in linguaggio macchina, che verosimilmente è stato scritto in cc++ o in rastro, in qualche linguaggio che viene compilato. Quindi c'è una serie di barriere linguistiche intermedie fra noi e la macchina. Qui si tratta solo di aggiungerne un'altra, quindi non è che stiamo facendo chissà qual operazione, operando quale perversione. Però questo secondo me avvicinerebbe di più la programmazione al linguaggio. Quindi, secondo me, invece la frontiera o comunque la strada è proprio l'opposta. La matematica rimane dietro le quinte, ci sarà sempre qualcuno che deve conoscere ovviamente i fondamenti, i principi, perché poi i linguaggi di base su cui sono fatti gli altri funzionano in in quel modo. Ma l'utilizzatore potrà essere una persona che è negata per la matematica, ma che si sa esprimere bene a parole per chiedere a un sistema di intelligenza artificiale di scrivergli un programma che fa una cosa per lui. E' chiaro che questo, su vasta scala, vorrebbe dire la fine degli informatici, perché ognuno non ci sarebbe più bisogno di rivolgersi a un'azienda di informatica per farsi fare un programma. Non sarà mai così. Però in piccolo compito che devo fare io personalmente, potrò chiedere alla macchina di farlo e quello programmerà per me. Ma se io gli dico di farlo e lui mi scrive il programma, non è diverso da io che scrivo in python e lui mi compila il mio codice python in bytecode. Traduce da un linguaggio a un altro. In questo caso tradurrebbe da linguaggio naturale a un linguaggio che poi viene immediatamente eseguito dalla macchina come java, script python eccetera. Quindi secondo me la programmazione potrà potrà tornare in qualche modo in auge da questo punto di vista. Non sarà una programmazione come piace a noi, che stiamo a capigliarci su dove mettere la parentesi graffa, diciamo, lasciamolo un po' nei ricordi romantici del passato, esattamente come alcuni linguaggi che io amo tantissimo oggi non si programmano più. Io mi iscrivo da solo un compilatore per programmare in quel linguaggio, me lo faccio di sera, mi diverto così. Però diciamo, nell'utilizzare le macchine e il software per fare delle cose utili per noi, probabilmente potremo molto spesso usare, in ambiti ristretti, la lingua naturale, il nostro linguaggio. Ciascuno ne ha la sua lingua e farcelo produrre. Quindi forse questo ci riconcilierà un po' di più con la programmazione e renderà le persone, anche che non sono versate in matematica, anche quelli che dicono "io sono negato", quelli che dicono spesso, ne ho conosciuti tanti. Io sono negato per la matematica, non ci capisco niente dei calcoli, quindi non capisco niente neanche di computer, senza neanche provare invece a interfacciarsi con un computer. Forse quello stacolo verrà vinto e forse la programmazione diventerà un'arte un po' più letteraria, narrativa, quindi magari anche più interessante, più divertente. Di recente sono usciti degli articoli molto interessanti su come diminuire le allucinazioni che i large language model hanno. sappiamo tutti che ogni tanto ci hanno questi svarioni, quindi anche quando scrivono codici hanno degli svarioni. A chi è in ascolto, se usate per produrre codice chat gpt, scrivete voi i test di quel codice così siete sicuri di quello che fa. diciamo, adesso non mi ricordo cosa stavo dicendo, ho fatto questo discorso... - No, parlavi delle allucinazioni. - Eh, le allucinazioni. Allora, di recente ci sono stati degli articoli nei quali si propone di utilizzare la dialettica socratica, il metodo che si trova nei dialoghi di Platone con cui Socrate interloquiva con i propri interlocutori per tirare fuori conoscenza, lo applicano per parlare con ciascuno e far sì che lui risponda come noi vogliamo. Quindi, in qualche modo, la programmazione potrebbe diventare un'arte oratoria, narrativa o poetica. Insomma, sono degli sviluppi da non trascurare. Poi, chiaramente, per rispondere di nuovo a Luca, è chiaro che io sono un matematico, A me un linguaggio puramente matematico piacerebbe tantissimo, e ci sono. Però mi rendo conto che sia in ambito produttivo che in ambito di user experience, dove lo user in questo caso è il programmatore, quindi colui che usa la macchina per fare cose, sicuramente andare verso il linguaggio naturale invece semplifica, democratizza e probabilmente è la strada giusta. Adesso che abbiamo gli strumenti che sembrano essere in grado di farlo. non penso che a breve potremo utilizzare un computer. Io che lavoro in un'azienda che non è di informatica potrò cacciare i miei fornitori e sostituirli con un chat gpt e farmi scrivere da lui da zero un'applicazione. Però il mio fornitore potrà usarlo per scrivere delle parti e magari scriverle anche meglio, e magari farsi scrivere la documentazione, e magari farsi fare i commenti nel codice, magari utilizzare questi strumenti per ampliare l'ambito della programmazione all'improvviso, al di là della parentesi graffa aperta e chiusa che a noi piace tanto. Quindi, pur essendo di indole, oltre ad essere un boomer anagraficamente, ma in indole legato molto alle sintassi, ai linguaggi e a tutto, mi rendo conto che la strada da seguire invece è quella che gli strumenti tecnologici di oggi ci tracciano. Come dicevo prima, alla fine è la tecnologia e la comunità che guida e che fa evolvere i linguaggi. Non è che i linguaggi si evolvono da soli. Se si evolvono da soli vanno in disuso. Alcuni linguaggi perdono la comunità di riferimento, perdono il prologue, per esempio. Oggi non vi dice nulla la parola prologue, negli anni '80 era il linguaggio più usato nell'intelligenza artificiale. E poi ha perso, non è riuscito a fornire gli strumenti necessari per sostenere i nuovi sviluppi dell'intelligenza artificiale, non era per nulla ancorato alla tecnologia dei computer, dei dispositivi, era un linguaggio totalmente astratto ed ecco lì che non esiste più, si è estinto, un po' come un dinosauro. Mentre invece il Fortran, che è un fossile vivente, esiste dal 1954 perché ogni cinque anni ne fanno una revisione e tu in Fortran riesci, il Fortran è il linguaggio ancora oggi nel quale scrivere codici è più efficiente. Se tu devi scrivere un programma di calcolo numerico parallelo lo puoi fare in Fortran, ti offre tutti gli strumenti per farlo e tu scrivi una cosa che in qualunque altro linguaggio non riuscirai a ottenere la stessa performance. Quindi, in questo modo, inseguendo in qualche modo la tecnologia, non tanto avendo versioni nuove, ma avendo nuove implementazioni, quel linguaggio è ancora vivo e vegeto e ancora ha una ragione d'essere. Per cui, secondo me, alla fine, mi ripeto, il linguaggio segue gli utilizzatori e gli utilizzatori seguono le nuove tecnologie. E quindi la programmazione, secondo me, potrebbe diventare un'arte narrativa, un'arte poetica, in alcuni aspetti mantenere un aspetto matematico, perché poi certe cose, alla fine, se tu devi descrivere a chat gpt una formula matematica a parole per fartela scrivere poi in java, fai prima scriverla tu in java ovviamente. Però in generale questo potrebbe essere uno sviluppo che io non vedo come negativo, insomma, io vedo una nuova vita diciamo per la programmazione rispetto al copia e incolla che si è fatto fino all'altro giorno. Facciamolo fare a chat gpt copia e incolla. E noi programmatori concentriamoci su qualcosa di più interessante. Quello che mi spaventa di questa potenziale evoluzione è vedere supercazzole dialettiche per far fare a chat gpt una cosa che in realtà con un linguaggio di programmazione semplice qualunque potresti fare con due comandi e mezzo. Quindi probabilmente ancora legato all'immaturità dello strumento. No, ma è quello che dicevo prima. Nel senso, se io devo scrivere una formula, le formule sono state inventate proprio per non doverle dire a parole. Fino al '500 i matematici non avevano le formule, per cui se tu dovevi dire l'equazione di secondo grado, dicevi prendi una quantità, ne fai il quadrato, poi la sommi a un... capito? Invece con la formula, la scrivi, è molto più facile. Quindi alcune cose si continueranno a fare nel linguaggio di programmazione, altre cose gliele direi nella lingua naturale. L'una cosa non esclude l'altra, ogni cosa ha il suo strumento di riferimento. Io vedo in una pluralità di strumenti il progresso, per cui continuiamo a usare, non so, Python. Però certi pezzi di Python, che a me viene noioso fare, oppure che ci metterei tempo, ti scrivo quello che voglio e tu me li fai. Io intanto faccio qualcosa. LM: le espressioni regolari, per esempio. DL: espressioni regolari, che cambiano di poco da un linguaggio all'altro. LM: perché è un linguaggio a sé stante, tra l'altro, è il famoso paradigma pattern matching. DL: guardate, io consiglio a tutti chi è in ascolto e che ancora non si è suicidato per tutti questi discorsi che stiamo facendo, approfonditelo, cercatelo su inter, c'è linguaggio che si chiama "Snowball", è un linguaggio degli anni '60, che è stato il primo linguaggio a usare effettivamente il pattern matching. Le istruzioni di quel linguaggio sono dei pattern e in base al match che fai poi lui fa un'azione, un po' come certi strumenti Unix, tipo Lex, Ovc, eccetera. Anche lì il pattern matching è una cosa che ha una storia antica, però chi è refrattario a scrivere? Io conosco persone che ci sguazzano le espressioni regolari, poi ci sta qualcuno che è refrattario a scriverle e se le fa scrivere da cialgpd, esattamente come oggi andrebbe da un collega a dirgli "senti, mi scrivi tu le espressioni regolari che devo mettere in questa query?" Mi è successo varie volte di ascoltare questa cosa, l'esperto di SQL a un certo punto deve scrivere una query complicatissima, super annidata, che chi scrive le espressioni regolari non saprebbe scrivere, però ci deve mettere un pattern, allora chiede a uno che si intende a espressioni regolari di scriverle e lo farai con chat gpt. LM: non so se nello specifico, non buona idea. Proprio le espressioni regolari adesso. DLL: va beh, adesso è venuto fuori questo esempio così. LM: però sì, forse te ne accorgi subito. Perché lavorando a livello statistico, le espressioni regolari sono a volte ridondanti. Forse qualche parentesi di troppo potrebbe scappare a ChangePT, quindi no niente, stavo soltanto pensando a questo. Però se volete provare a farvi dare qualche regex da ChangePT, non banale, insomma, non nota qualcosa di particolarmente strano, forse potrebbe essere divertente il risultato. nel frattempo si è fusa la mia camera, ho dovuto cambiare fotocamera, fate finta di niente no, pensavo però quando diceva Paolo "no, lasciamo fare allo strumento un po' di cose" pensavo a un fan fact di oggi dove avevo una mappa con le lingue nel formato ISO, non so che cosa gli avevo detto convertimeli in un array di string e lui ci ha anticipato molto intelligentemente mi ha messo i primi due elementi poi mi ha messo inserisci qui le altre sì ma cazzo se lo sto chiedendo a te dovevi dire per favore probabilmente dovevi dire per favore ah ma io lo dico sempre ho paura che quando le intelligenze artificiali prenderanno il - Non lo diranno, tu sei maleducato. Guardavo l'orologio, Paolo, è stata una chiacchierata fighissima e tra l'altro io direi che magari ci risentiamo perché tutta la parte di correlazione tra poesia e scrittura del codice voglio proprio approfondirla. Io spesso ricordo le parole di una mia carissima amica che non c'è più, che faceva la poetessa, si chiamava Vittoria, diceva "le parole sono lo strumento con cui costruiamo i pensieri e più parole più costrutti abbiamo più pensieri articolati riusciamo a costruire" e secondo me vale anche per quanto riguarda i linguaggi di programmazione tanto che quando noi impariamo due, tre, quattro linguaggi di programmazione anche se poi ritorniamo a scrivere nel nostro linguaggio madre il nostro il nostro pensiero non è più lo stesso. Il modo in cui vediamo per esempio io quando ho iniziato a studiare Scala che è diciamo il canarino nero dei linguaggi funzionali io non ho più utilizzato for loop while in javascript. Io se tu leggi il mio codice non c'è un for, lo so che le prestazioni ne risentono perché conosco come funziona javascript e mi odierebbe però io se se mi togli i map e i radius muoio oggi e questo mi viene proprio dallo shift mentale che ho fatto nello studiare un nuovo linguaggio e quindi dotarmi di nuovi strumenti espressivi. Detto questo io direi che possiamo andare al nostro momento tipico e topico dell'episodio, momento nel quale condividiamo con la community un libro, un tool, un videogioco, un disco, qualunque cosa abbia catturato la nostra attenzione e pensiamo sia utile condividere con gli ascoltatori di Gitbar e con la community appunto del nostro podcast. Per cui Paolo ti chiedo, hai qualcosa da condividere con noi? "E conduco nel paese dei balocchi" "Ah, il paese dei balocchi" Sendo anziano mi vengono in mente diversi libri, ma diciamo che quello che vorrei condividere è quello che ho citato prima, perché è un libro secondo me troppo poco noto. In generale vi consiglio questo, comprate qualunque libro di Brian Kernighan, dall'ultimo che ha scritto sull'inguaggio Go, ne ha scritto uno bellissimo che si chiama "D for Digital", che è un'introduzione all'informatica per i non informatici, nella quale peraltro per introdurre la programmazione usa proprio javascript. Lui pensa che javascript sia il linguaggio più facile per introdurre la programmazione a un non informatico, che è una cosa molto interessante. Quindi, sicuramente un libro di Kernighan. Ne ha scritti tanti, sono classici, il mio preferito è quello sul C, ma questo che si chiama "La pratica", "The practice of programming", l'ha scritto in coppia con Robert Pike, credo, che è uno degli inventori del Go. Quello è un libro che merita sicuramente di essere letto. Questa è quella che mi viene in mente. Poi una cosa che stavo guardando qualche tempo fa, che vi posso consigliare, è un... fate una ricerca su internet e lo trovate, è un programma che secondo me è bellissimo, che è stato scritto negli anni 60 da un matematico che si chiama Weizenbaum, un programma famoso che si chiama Eliza. Era un programma di conversazione, un chat, che simulava uno psicologo. È molto famoso ed è un programma che oggi, a implementarlo in Python, sono 30 righe di codice. Questa Eliza di recente è stato studiato in un paper scientifico, nel quale lo confrontano, lo sottopongono al test di Turing insieme a CHAT GPT 3.5.4 e ha performato molto bene, incredibilmente, pur essendo un programma di una semplicità disarmante, ma di una grande eleganza. Cercate su internet Eliza, è scritto ovviamente Eliza, c'è anche un sito dove c'è il codice originale, scritto in un linguaggio esotico che si chiama Mad Sleep, però lo trovate scritto in Python o in qualunque linguaggio. È un pezzo di informatica che vale la pena conoscere ed è basato sul pattern matching, peraltro, di cui parlavamo prima. Quindi un libro è un oggetto immateriale, vi posso consigliare. Poi sarebbe interessante consigliarvi qualche film, però in in questo momento non ho qualche serie, però non mi vengono in mente cose particolarmente adatte a quello che abbiamo detto oggi. Però vi lascio con questo, insomma, un libro e un programma di altri tempi che però ancora riuscite a trovare. Se lo cercate in rete, lo trovate sicuramente. sei muto Mauro? No sono pirla, non sono muto. Trovate tutto nelle note dell'episodio comunque. Grazie Paolo. Luca hai qualcosa con noi? Per noi? Sì, innanzitutto è bellissimo. Stavo vedendo adesso Elisa su Wikipedia, ma quante cose che ci siamo persi quando non eravamo nati, mannaggia la miseria! Però è tutto molto interessante. Allora, la prima è un rebalocco che evidentemente non sono stato abbastanza incisivo né con te né con Carmine che si è comprato una moca da uno, mannaggia, stamattina mi diceva. Insisto con la cammina, se vi piace il caffè e non volete avere la macchinetta espresso per un qualsiasi motivo, se siete ancora romantici con la moca ma vivete in uno o in due, fare una moca da quattro è troppo, oppure quella che avete non va bene eccetera eccetera. La potete comprare su internet, Camira, è fatta da un siciliano, tra l'altro la brevettata "oh il caffè che fa mi piace, non c'è niente da fare" ha la ritualità della mocha ma è ovviamente più veloce ed è da uno oppure da due. Il caffè è molto molto molto buono. Mauro è Natale dai regalatelo. MAURO: sì se mi confermi che funziona sul piatto a induzione. LUCA MAZZUCCHELLI: ce l'ho l'induzione. MAURO: e tra l'altro mi hai consigliato un ottimo regalo di Natale per mia mamma. LUCA MAZZUCCHELLI: che è questo? O te l'ho un altro. Attenzione che non è facile da fare. All'inizio devi seguire un po' di istruzioni perché c'è una valvola che devi aprire, devi chiudere, poi devi riaprire, metti l'acqua, richiudi. Non è facile, però una volta che hai la ritualità lo sai fare. È un algoritmo alla fine, lo devi seguire. Non so se tua mamma… LM: no, no, io non ho dubbi su mia mamma, io ho dei dubbi su me. La mattina quando faccio il caffè io non ho la lucidità di aprire valvole e chiudere valvole. Però potremmo trovare magari un motorino automatizzato. LM: sì, potremmo mettere un raspberry vicino e farlo. Mentre invece un libricino che ha si c***o la mia attenzione. Non chiedetemi come, non chiedetemi perché, ma mio figlio di 11 anni, una volta, una volta un paio di settimane fa, abbiamo cominciato a parlare della relatività, della velocità della luce, ma cosa succede, il tempo si restringe, non so chi gli abbia messo in testa queste idee malsane. Comunque io fino a un certo punto riuscivo a rispondere, perché bene o male, per fortuna, sono appassionato, quindi qualcosa so. A un certo punto sono andato su Amazon e ho comprato il libro adatto per i bambini che spiega bene la relatività e si chiama appunto "Il mio primo libro della relatività". Ovviamente è illustrato giochi giochini per far capire bene un po' questa stranezza che succede quando si viaggia a velocità molto molto elevate. È spiegato bene, spero che forse nel futuro questi concetti dovranno essere capiti per capire meglio la realtà circostante, ma magari riusciremo a viaggiare non alla velocità della luce ovviamente, ma cominciare a vedere qualche effetto relativistico forse nella quotidianità, intendo. Quindi niente. LM: scusa se posso interromperti, il GPS è basato sulla relatività. Cioè senza la relatività, né speciale né generale, perché ci sono due correzioni, il GPS non funzionerebbe. Quindi è un concetto, tutto sommato, che molti di noi lo usano il GPS. Quindi quello un concetto della quotidianità. Scusa se ti ho mancato il vestito. No, non mi hai visto. Hai per poter mettere giù, tra l'altro lo sapevo anche. Tocca a me. Allora io ho un balocco particolare. Abbiamo parlato di chat gpt e di far scrivere il codice chat gpt con i dovuti problemi appunto nel dare il nostro codice a delle entità che sono private, bim bum bam, mille cose e via discorrendo. Vi ho parlato lungamente nel nostro podcast. Morale della favola, qualche giorno fa io lavoro in un progetto dove Copilot non può essere usato per una questione di policy. Cercando qua e là ho trovato un'alternativa, non l'ho ancora provata ma mi sembra una figata pazzesca, si chiama Tabby ed è un modello self-hosted con tutti gli strumenti che lo rendono un piccolo copilot, molto molto carino e nulla insomma è un selfhosted AI coding assistant provatelo e ditemi un po' come è andata vi metto il tutto nelle note dell'episodio. Wow il tempo è volato abbiamo aperto un libro di storia che sai quando si parla di storia e si prova a tornare indietro ad osservare ciò che è stato probabilmente si è in grado di osservare il presente con occhi diversi e questo è il percorso, era l'idea che volevamo quando che volevamo raggiungere quando abbiamo invitato Paolo e grazie a lui infatti ci siamo riusciti benissimo cioè ci siamo dotati di per quanto piccoli, per quanto strumenti in un'ora e mezza di strumenti per osservare il presente con un occhio un pochino diverso e quindi per questo Paolo noi ti ringraziamo tantissimo. Grazie a voi, grazie a voi. Detto questo ringraziando nuovamente a Paolo e ricordandogli che Gitbar è un po' tipo il circolo del dopolavoro ferroviario, non so se te lo ricordi, negli anni 70 andava molto di moda il dopolavoro, noi siamo il dopolavoro degli sviluppatori, è un po' come quella... hai presenti i circoli arci dove tu entravi per bere una birra e appena entravi loro ti facevano la tessera e da quel momento in poi tu eri tesserato al circolo alla bocciofila del non so che cosa, ecco sentiti tesserato in github e sentilo un po' come casa tua, quindi quando hai qualcosa di interessante che ti fa piacere collidere con noi c'è sempre una birra fresca per te. Perfetto, grazie mille, sicuramente, anche perché la birra fresca fa sempre piacere Al suo affile Se non muoio Prima io ringrazio anche Luca per essere stato con noi in questo episodio dove abbiamo provato con Paolo ad ascoltare, a immaginare, a rivedere un pezzo di storia della nostra industria quindi grazie Luca, grazie di cuore per essere venuto. Io vi ricordo rapidamente i nostri contati info@gitbar.it @brainrepo su Twitter e come sempre il gruppo Telegram, aprite Telegram e cercate Gitbar Podcast e ci siamo noi. 1500 iscritti più o meno ad oggi, siamo a dicembre 2023, entrate, birra offerta, salutate mi raccomando così ve la possiamo dare. Aggiungo anche che abbiamo un canale youtube "Giovane Giovane" siamo i noobissimi nel mondo di youtube per cui se vi fa piacere iscrivetevi e cliccate sulla campanella così vedete anche le nostre facce, la mia non bellissima, ci sono spurso sempre gli ospiti e i co-host che insomma vale la pena vedere e poi ci tengo a ricordarvi una cosa ne ho parlato poco fa nel gruppo telegram riguardo al podcasting si parlava di che cliente utilizzare per ascoltare podcast io sono un po radicale in questo per me il podcast è un bel feed rss con un file mp3 dentro per cui se volete ascoltare podcast cercando di tenere viva questa tecnologia e non farla entrare nel meccanismo dei wallet garden e via discorrendo, dotatevi di un client podcast che sappia leggere un rss e sappia capire che cos'è un mp3 e mettere insieme queste due cose. Per farlo esiste un sito si chiama newpodcastapps.com fatto dai ragazzi di podcast index che sono padrini del podcasting c'è un Adam Carey che è uno dei co-inventori del podcast quindi insomma buttateci un occhio e là c'è una sorta di directory dove sono catalogate tutte le applicazioni che sono dei podcast player che vi permettono tra le tante cose di utilizzare tutte le caratteristiche del podcasting 2.0 dalle trascrizioni ai pulsanti per supportarci, alla lettura degli host e degli ospiti, insomma tutte quelle funzionalità che rendono il podcast uno strumento moderno e soprattutto libero per cui buttateci un occhio, insomma lo so sono un po' rompibale, c'è una puzza un po' stalmaniana ma in questo momento ci tengo molto a dirlo e per me è importante. Ringraziando di nuovo Paolo per essere venuto a trovarci, ringraziando Luca, noi vi diamo appuntamento la prossima settimana e è tutto. Ciao ciao! ciao ciao ciao! [Musica]