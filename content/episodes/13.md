---
---

## Descrizione

Immaginate di ordinare 10 caffè alla macchinetta inserendo una moneta alla volta e aspettando ogni singolo caffè. Frustrante, vero? Questo è esattamente il problema delle API REST quando dobbiamo fare richieste multiple. In questa puntata parliamo di GraphQL, nato in Facebook nel 2012 quando dovevano riscrivere le app per mobile e si sono accorti che le API REST non bastavano più. Esploriamo come GraphQL sia un linguaggio di query descrittivo (non imperativo come SQL), un sistema di tipi che definisce la gerarchia dei dati come sentieri in un bosco, e un runtime che converte tutto. Scopriamo che Twitter usa GraphQL per nascondere microservizi e database diversi dietro un'unica API, e che Gatsby lo usa per attingere dati da file markdown e altre fonti.

## Takeaway

- GraphQL nasce dall'esigenza mobile: client più intelligenti, connessioni instabili, bisogno di conservare stato
- Tre pilastri: query language descrittivo, sistema di tipi (la mappa dei sentieri nel bosco), runtime di conversione
- Query e Mutators: le query leggono, i mutators modificano (come POST/PUT in REST)
- Una sola chiamata per traversare l'albero degli oggetti, contro le N chiamate REST e i join SQL complessi
- Tool ecosistema: Apollo (server/client JS), Prisma (ORM), Relay (client React), GraphiQL (explorer)

## Bold Opinion

- GraphQL permette di astrarre infrastrutture complesse: Twitter nasconde microservizi dietro un'unica API elegante
- I contro sono reali: caching complicato e rischio di query troppo profonde che mandano in tilt il backend
- La libertà di GraphQL è un'arma a doppio taglio: il frontend può mandare al collasso il sistema con query mostruose
- Per la sua vicinanza al business language diventerà uno standard industriale (e infatti GitHub, Twitter, Facebook già lo usano)

