---
---

## Descrizione

In questa puntata chiacchieriamo con Massimiliano Arione (Gracchio), presidente del Pug Roma e storico membro del Grusp, che ci accompagna nel mondo del Domain Driven Design e del Rich Domain Model. Parliamo di come PHP sia cresciuto dall'essere un linguaggio "da script kiddie" a un linguaggio enterprise maturo, della differenza tra entità anemiche e ricche, e di perché avere più classi non è verbosità inutile ma rispetto del principio della singola responsabilità. E sì, i DTO non sono il demonio.

## Takeaway

- **PHP è maturato insieme ai suoi sviluppatori**: Dal semplice tool per fare CRUD velocemente (tipo Laravel o Symfony 1) è diventato un linguaggio con cui si può fare DDD serio, grazie anche all'evoluzione della community e dei framework.
- **Rich Model vs Anemic Model**: Il Rich Model mette la business logic nelle entità, che si auto-validano e mantengono la coerenza interna. L'Anemic Model è piatto sulla persistenza (solo getter/setter), perfetto per CRUD ma disastroso quando il dominio si complica.
- **Le entità non devono conoscere la persistenza**: No alle annotation di Doctrine sulle entità. Mapparle con file YAML/XML esterni, usare DTO per i form, e costruire l'entità dal DTO in uno stato già valido.
- **Più classi = meglio, non peggio**: Avere DTO, entità, form separati significa rispettare la Single Responsibility Principle. Classi più piccole e specifiche sono più facili da capire, manutenere ed evolvere.
- **DDD si sposa perfettamente con Symfony**: A differenza di Laravel che ti spinge verso il RAD e i CRUD, Symfony ha la flessibilità per fare sia RAD (Easy Admin Bundle) che DDD serio. E Doctrine supporta entrambi gli approcci.

## Bold Opinion

- **Laravel è il ritorno a Symfony 1**: Punta tutto sul RAD e sui CRUD generati automaticamente, come Ruby on Rails. Funziona per le startup e i prototipi, ma ti porti dietro un debito tecnico che ti schiaccia quando il progetto cresce.
- **Il cliente va guidato, non assecondato**: Nella fase di raccolta requisiti con DDD bisogna guidare il cliente per evitare che metta troppa carne sul fuoco. Non bisogna modellare tutto lo scibile umano.
- **Non avere paura di cambiare gli aggregati in corsa**: Alcune entità si aggregano facilmente, altre no. Non bisogna scolpirle nella pietra. Rifattorizzare il modello durante lo sviluppo è normale e salutare.
- **Le specifiche in Gherkin sono oro, ma non per tutti**: Sono perfette per aziende strutturate con un reparto QA dedicato, ma per freelance con clienti piccoli diventano un livello in più che può schiacciare. Vanno usate per le aree critiche, non per tutto.

