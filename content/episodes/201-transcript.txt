Benvenuti su Gitbar, il podcast dedicato al mondo dei full stack developer, i mezzo artigiani, i mezzo artisti che ogni giorno infilano le mani nel fango per creare nel modo più efficiente possibile quei prodotti digitali che quotidianamente usiamo. Allora, buonasera o buongiorno, insomma da quando ci state sentendo, ma come sempre bene e benvenuti su GitBar. Questa sera sono in compagnia di Luca. Diciamolo bene, benvenuti a tutti. Anche se siamo un po' tornati alle stagioni precedenti, mi sa che abbiamo cannato la sigla. No, è una puntata nuova del luglio del 2024. Sì, sì. Siamo sottocirretti e abbiamo cannato la sigla. Ma va bene, lo spettacolo. Allora, che dove comincia? Assolutamente. Questa sera non c'è Mauro, è ancora nello sgabuzzino agli e-libri dell'apogeeo su PHP, quindi questa sera non può essere qui. 5.4. 5.4, esatto. Questa sera non può essere qui, ma questa sera siamo con un ospite che lo dico personalmente, volevo invitare su GitBar da giorno zero, ma non ci ho mai avuto, insomma, diciamo, l'occasione giusta per farlo. non faccio scuola, poi mi piace non faccio scuola, questo ho fatto letteralmente il video e c'è l'audio con il nome dell'ospite nel titolo, però va bene così, non fa niente, buonasera e benvenuto a Paolo Overrotta, ciao Paolo, chi sei, che cosa fai? Anzitutto smuto. Ora ti ho smutato. Mi hai smutato? Perché suona malissimo detta così. Ciao Carmio e ciao Luca. Sono... grazie per avermi preso qui. Sono molto contento. sono un programmatore, un autore di libri, un un insegnante online, un parlatore seriale alle conferenze di software e sono anche capace di scrivere codice così in subordine lo faccio davvero anche se ultimamente devo ammettere purtroppo sempre meno anche perché i capelli grigi mi penalizzano non non vengo preso sul serio ma diciamo sono una vita per la programmazione ecco. Questa qua è una definizione bellissima, un vita per la programmazione, sai quelle cose che si scrivono sulla bio, su LinkedIn, vediamo una video terminalista metalmeccanico. Ok, allora, in realtà giusto così per dare un po' di contesto, io ho scoperto Paolo nel lontano 2015, 2016. Non lo ricordo l'anno. No, lo ricordo io, insomma, 2015, 2016, perché, insomma, uno dei miei primi lavori è stato quello, insomma, di sviluppatore web con Rubio Rails. E, diciamo, tra le varie cose, insomma, ma sono così tra le varie risorse che c'erano. Mi ricordo che in ufficio c'era questo libro che mi dicevano "sì, però leggitelo solo dopo". C'era quel lalune di mistero. "Sì, vedi, prima questa cosa, guardi la documentazione, un po' quelle raccomandazioni iniziali che si fanno". E il tipo "hai presente quello che c'è scritto sulla documentazione? Noi l'abbiamo fatto un po' così, perché sai, poi..." Ok, insomma, quindi c'era tutta questa roba qui, e poi ero con un mio amico e collega all'epoca, David, e mi diceva "guarda, c'è questo controller" che io ricordo che era un controller estremamente fine, cioè nel senso fine proprio di righe di cose, e poi faceva un sacco di lontananza, non sapeva un cazzo, cioè, proprio, era terribile. e mi diceva questo qua per il momento fai finte niente e poi ci si arriva. E mi ricordo che era bello perché quando si rompeva ciò che c'era nella stack trace nel codice non c'era. E io bestedìa. Cioè questo metodo non esiste. Ma com'è possibile che questa cosa si rompa? Quindi chiedendo, chiedendo, un giornalista che ci devo mettere mano pure io, mi dicono guarda questa roba qui è tutta metaprogrammazione, perché abbiamo bisogno di astrarre alcuni concetti, così se ne vuoi capire di più c'è il libro magico, provala, leggilo. La chiave del regno. Sì, sì, esatto. La chiave del regno. Dico, boh, ok, allora lo prendo così. Ed è stata una cosa illuminante. Cioè io credo che sia uno dei motivi per cui mi piace moltissimo Ruby ed è anche uno dei motivi per cui attendere. Ora io faccio Elixir, cioè ho fatto proprio Ruby, Rails, Elixir Phoenix. la pat insomma un po' più moderna. Quindi sono passato da quella roba lì alla macro, però nel senso più o meno ci ritroviamo vicini ed è uno dei motivi per cui nei progetti personali mi piace tantissimo Ruby, perché nel senso... perché leggere quel libro e scoprire diciamo in generale il mondo della metà programmazione è stata una cosa... non lo so, è come se ti sbloccasse le chiavi per fare qualche cosa che almeno per me all'epoca era elitarismo spicciolo. Io so fare questa cosa e tu no. Si era proprio così. Che poi il 99.9% erano delle robe inguardabili. Il metodo preso, generato dal database, era una roba inguardabile, però insomma mi faceva sentire... lunghi rotoli di corde, di rastagliere intere di fucile con cui spararsi nel piede. Sì, sì, esatto, esatto, sì, sì, era quella cosa lì. Anche perché poi mi sono cominciato ad appassionare in generale al monto della metaprogrammazione, che se ci si sta chiedendo si può fare in tantissimi linguaggi. Chi lo ha fatto in PHP sa che anche lì si soffre moltissimo, io ho visto delle robe scritte che ho scritto in PHP, cioè quando vedevo quel metodino con due underscore davanti mi sapevo un'ansia terribile, perché sapevo che c'era qualche cosa che stava insomma succedendo. Anche perché in PHP penso che l'abbiano, che sia retrofittata, penso che l'abbiano aggiunta dopo. Però vuoi che spieghi in parole poverissime? Assolutamente. Che cos'è la metaprogrammazione? Cos'è metaprogrammazione? Lo sintetizzo così. Quando tu programmi con un linguaggio di programmazione, normalmente utilizzi i costrutti del linguaggio, le variabili, i metodi, le classi in un linguaggio che ha le classi, gli oggetti, e li usi così come linguaggio prescrive. La metaprogrammazione vuol dire che tu... scusa mi faccio un passo indietro, lo spiego meglio... e tipicamente ci sono due fasi nel ciclo di vita del tuo programma. La prima è la fase di design time, poi c'è la runtime, nei linguaggi compilati le due fasi sono estremamente distinte in modo anche ovvio, nei linguaggi interpretati meno, ma comunque c'è la roba che tu fai quando guardi il codice lo manipoli e la roba che fai che il tuo codice può fare mentre sta girando e di solito c'è un muro in mezzo cioè ad esempio tu in java puoi definire le classi nel codice esplicitamente non puoi decidere di definire una classe runtime che non era prevista design time. Quello che c'era design time è già la struttura del programma, le classi, quali oggetti circa vengono instanziati, poi ne puoi instanziare più o meno, ma la questa struttura, questa impalcatura che poi viene verificata a runtime è già lì nel il codice la vedi. La metaprogrammazione vuol dire che tu definisci nuovi costrotti del linguaggio mentre il sistema gira. Nel senso che decidi a run time, il tuo codice lo decide, per esempio di definire una classe e la definisci al volo, di definire un metodo, di definire una nuova lambda o come la vuoi chiamare a seconda del linguaggio che stai usando. In In pratica tu intervieni direttamente su questa struttura. Ed è una cosa che detta così sembra una sega mentale accademica spaventosa, ma quando poi inizi a capire quali sono le conseguenze a livello tecnico ti rendi conto di avere a disposizione una potenza che altrimenti non avresti. E quindi ovviamente ne abusi, scrivendo codice che poi lasci lì come un manufatto alieno per cui i tuoi colleghi dopo qualche anno ti odiano, ma lo puoi anche usare a fin di bene. Grande potere, grande responsabilità", diceva Zir Ben. Ok, quindi appunto, mentre si parlava appunto della metaprogrammazione, mi immaginavo proprio bazooka e uno sciame di mosche che stanno, che uno vuole sparare con quel bazooka. Però, entrambi prima avevate detto che avevate nominato Ruby, che sembra più indicato per fare metroprogrammazione, ha degli strumenti più particolari per la metroprogrammazione rispetto ad altri? io ruby è un linguaggio per il quale io insomma ho un bias qui è un linguaggio bellissimo senza nulla togliere gli altri e me ne piacciono tanti ma ruby è un posto speciale nel mio cuore perché è ispirato da due linguaggi che sono che ricevono tanto amore ma poco poco di concreto che sono uno, Smalltalk e Lisp. E di Lisp ha poco, l'influenza di Lisp è piuttosto sottile, ma si vede. Smalltalk invece è un linguaggio che è stato molto amato e poco usato al di fuori dell'ambito accademico e Ruby si ispira moltissimo a Smalltalk, ha una caratteristica smalltalk tutto e tutti oggetti all the way down tu puoi entrare nel modello oggetti appunto e farne un po quello che vuoi a design time a runtime esplicitamente il tuo codice attraverso metà programmazione e rubia ripreso questa cosa in pieno hai ragione luca e un bazooka e quindi se lo usi per sparare le mosche lo stai usando male ovviamente sta facendo una cazzata e appunto ti lasci dietro dolore e distruzione. Ma ci sono dei casi in cui invece ti permette di fare delle cose che altrimenti non potresti. Il caso tipico è tu non stai scrivendo un'applicazione ma stai scrivendo una libreria. Codice che verrà usato dagli autori di applicazioni perché poi c'è un modo diverso di programmare se tu scrivi codice che verrà usato direttamente a qualcun altro e per queste cose la metà programmazione è insostituibile a mio avviso ci sono infatti delle librerie ruby che hanno fatto scuole sono state imitate male da linguaggi che non hanno lo stesso tipo le stesse feature quindi non hanno la stessa flessibilità e potenza. L'esempio classico è quello di Sinatra che è una libreria web che funziona e viene usata in produzione che sta tutto in un unico file e tutto avviene magicamente a runtime e questo non è solo un vezzo tecnologico a livello di uso è facilissima, comodissima, anche limitata se vogliamo, però molto semplice per chi è usa la metà programmazione. Beh, quindi già una buona rule of thumb per dire ok se stai facendo una libreria già puoi strizzare l'occhio un po' più volentieri alla metà programmazione, se stai facendo un'applicazione forse, pensaci un po' di più. È corretto come visione oppure... Luca, sì è corretto. Cioè aggiungo una cosa, la figata della metaprogrammazione, questo può sembrare un po' gratuito, ma non è usarla ma è conoscerla. Perché quello che ne hai davvero quello che ti dà è un senso di padroneggiare lo strumento. Nello stesso modo in cui un musicista deve essere capace di eseguire il pezzo ipertecnico, quello che tutto il pubblico si rompe i coglioni, ma c'è una raffica di note che gli dà intima soddisfazione ma poi non lo esegue se non è necessario, se non gli viene richiesto. così come programmatore tu vuoi avere un senso di padronanza dei tuoi mezzi e questo ti dà la metà programmazione questo senso di minchia un potere immenso a mia disposizione e scelgo di non usarlo ma tare mate potrei potrei bellissima risposta benvenuto a leonardo che è venuto in in corsa. Ciao Leonardo. Ciao ciao, c'ho ancora il fiatone. Ciao Paolo, piacere. Allora ti faccio una domanda così, no? Il mio primo esempio di metaforamazione io l'ho visto all'università male, ok? Nel senso l'ho visto tipo con le macro in C, che per me è una roba veramente e lo sto dicendo, poi faccio una cosa simile nell'exilio e dico "che figo", però nel senso nel sentire comune, fai la macroencrypter e dici "madonna mia, che cosa brutta", no? Se dovessi paragonare l'esperienza, se ne hai avuto esperienza anche tu, insomma, di metaprogrammazioni Ruby o in un altro linguaggio. Nel senso, ad esempio, se devo paragonare tutta roba di metaprogrammazioni che ho fatto tra Ruby e JavaScript, ad esempio, JavaScript l'ho trovato un po' meno oscuro, perché alcune cose sono un po' documentate meglio, tra virgolette. Anche, nel senso, vai su MDN e più o meno capisci. Rubi invece lo sempre, cioè, Rubi, devi andare a leggere il libro tuo, insomma, non è che c'è stata tantissima, diciamo, letteratura anche ufficiale, sto dicendo una cazzata oppure no? Beh, letteratura ufficiale se uno vuole se la trova, però su una cosa ti do assolutamente ragione, io il libro l'ho scritto perché non trovavo documentazione, quello che successe fu che io iniziai a scavare un po' e sai come nei film de paura, apri la botola, c'è dietro il tunnel, che fai non ti ci infili e quando quando ebbi questa esperienza di "oddio ma qua c'è di tutto qui sotto, c'è un mondo che io non conosco" ricordo che l'unico che scriveva di questa roba è un programmatore svedese di nome Ola Bini, è un tipo particolare su generis e lui aveva un blog dove parlava di queste idee, di questa metà programmazione. Iniziava dalle cose dall'apparenza più diciamo più utili tipo guardate potete per esempio fare scrivere un metodo in una classe che acchiappa tutte le chiamate a metodo che non corrispondono a metodi già esistenti quindi praticamente diventa il metodo, l'asso piglia tutto delle chiamate che sono cose che ci sono oggi in moltissimi linguaggi dinamici quasi tutti direi no? addirittura molti linguaggi statici ce l'hanno questo concetto. All'epoca per molti programmatori era una tema, andavano molti linguaggi statici, Java, C#, non avevano aspetti dinamici. Allora io dissi "Ah, fico, quindi io posso prendere la chiamata e farci quello che voglio". Mi arrivano informazioni tipo "il nome del metodo con una stringa, posso smontarlo, decidere cosa fare in base al nome". Iniziai a rendermi conto che questo permetteva di fare cose che altrimenti non si sarebbero potuti fare. Allora scrissi a Olabbini, disse "ma..." aveva voglia di scrivere un libro, "ma se io scrivo un libro su questo tu..." e lui mi coraggiò, fu "insomma sì sì scriverai, io la mia serie di blog l'ho finita" e quindi iniziai a scrivere questo libro, che non l'avessi mai fatto perché ovviamente ci ha messo... pensavo di fare in sei mesi. Contattai i Pragmatic Programmers che all'epoca avevano la bibbia di Ruby, no? Il programmiro Ruby e di Rails anche. E accettarono e dissi "Ah bene, dai, scrivi un libro, figata". Poi ovviamente ci ho messo tre anni e mezzo soffrendo come una bestia. Dico sempre, se vi sembra che sia difficile estimare lo sviluppo il software, provate a scrivere un libro, è ridicolo. Io giuro che a un certo punto pensavo "va bene, un'altra settimana, dieci giorni ed è fatto" e col senno di poi mi mancava un anno. E' assurdo, non ci credi di quanto lavoro salta fuori. Comunque alla fine l'ho fatto tra l'altro Olabbini è ancora un personaggio pubblico perché credo che sia in galera attualmente perché è un collaboratore stretto di Julian Assange, lui era prevalentemente un hacker, un white hat e collaborava con Assange, ha vissuto per un certo periodo in Ecuador e l'hanno ingabbiato con scuse implausibili perché lo volevano ingabbiare. C'è stato anche un caso credo di Amnesty International, poi l'hanno rilasciato, non so se adesso l'abbiamo ripreso. Insomma, è un personaggio interessante, flessibile mentalmente, spazia. E quindi scrissi il libro per questo, per una curiosità intellettuale fondamentalmente. Però poi alla fine sapete cos'è della della metà programmazione? Io prima ho detto a Luca "sì vabbè se scrivi delle librerie" più specificamente la questione è questa il concetto di domain specific language gira ancora che io non sono molto aggiornato sulla sulle idee in programmazione. Si pare, l'ho sentito nominare. Assolutamente sì, assolutamente. Assa ancora, assolutamente. No perché, no lo chiedo senza, sinceramente perché sai sono quelle cose che magari a un certo punto tutti ne parlano, poi tutti se le dimenticano. No, no, no, assolutamente. non è che sei più giovane, magari non ve la no no no assolutamente eh alla fine eh insomma io ci lavoro con tutti gli altri tra l'altro insomma ne ne abbiamo anche scritto uno ultimamente per configurare una una roba specifica al lavoro abbiamo fatto con eh l'Xeer ma assolutamente è ancora lì insomma eh un altro che si Sì, ma allora ragazzi, vi faccio la domanda a tutti perché Paolo ha già risposto. Voi avete mai fatto metaprogrammazione? Che ne pensate? Probabilmente la risposta è sì, però sono estremamente curioso. Io ho esperienze un po' contrastanti. Volevo solo aprire una parentesi dicendo che ogni volta che parliamo di libri tecnici con un autore nessuno ha mai esperienze positive. Cioè non ci racconta mai "guarda è stato bello, ho imparato tanto". Alla fine non ho fatto neanche un sacco di soldi. Non c'è nulla di queste treci, solo il dark side. Aspetta, aspetta, no, Leonardo, allora mi devo pentire subito, faccio retromarcia subito. Io sono felicissimo di averlo fatto, sono contentissimo, sicuramente non ci sono diventato ricco. Avrei guadagnato di più facendo, che ne so, lavorando per esempio. Però detto questo, ha venduto molto, quel libro in particolare, molto più di quello che mi aspettavo. Ha venduto e guadagnato più di quello che mi aspettavo. e sono contentissimo, tanto è vero che poi tutte le volte giuro che non scriverò mai un altro libro per giurio orrendi, perché poi ne scrivo un altro e adesso sto preparando il terzo. Sì, però è proprio la sottostima dell'effort che ci vuole, che è una costante, perché uno ha un po' il non sapere di non sapere, che dici "ok, ci metto insieme e si può invece non sapere". Ma poi soprattutto io scrivo codice e scrivo il test, qual è lo unit test del libro? Non c'è? Questo è uno dei problemi, lo unit test è umano perché fondamentalmente io per dare un'idea inizio a scrivere questo libro, non avevo nessuna nozione di come scrivere un Ovviamente faccio la stima come manager, come fa il manager, moltiplica, quindi dico quanto mi ci vuole scrivere un blog post, quanto è grande un libro, fammi fare il rapporto e il tempo è quello. Ignoro di cosa mi aspettava. Inizio a scrivere e mi mi dicono loro, giustamente, tra l'altro loro sono fantastici, se mai scrivete un libro decisamente sono loro gli editori dove andare. E mi dicono, guarda, scrivi un capitolo fai con tuo comodo ce lo mandi e poi ti diciamo come va allora io scrivo un capitolo e io ero un... sono per carità un programmatore ma sono anche un giornalista abbastanza esperto, avevo dozzine di articoli al mio attivo quindi dico so benissimo come si fa che ci vuole va bene un articolone molto lungo scritto ben strutturato per entrare all'interno del libro scritto tutto l'ho mandato, ragazzi mi hanno steso proprio il feedback, è stato educatissimo, pulitissimo, ma mi hanno detto con una certa chiarezza che non non era leggibile, che non si capiva un cazzo, che era, mi ricordo in particolare mi dissero "guarda non c'è flusso in questo capitolo" e cioppi, salti da un argomento all'altro E io che ero così fiero della mia struttura proprio, io sono chiaro, scrivo bene, me lo rilessi un po' così, un po' barcollante, perché dicelo con un feedback così, me lo rileggo, aveva ragione al cento per cento. È stato un momento proprio di un bagno di umiltà, ho detto "ma io sta cosa non la so fare, ma io ho preso una scelta sbagliata, io non sono capace". E poi ho dovuto inventarmi qualcosa, l'ho riscritto e ho imparato a scrivere il libro come tutti, mentre lo scrivevo, perché è così che fa. Però l'esperienza, sì, è stata dolorosa, ma positiva, eh, per carità. Leonardo dice "Nessuno ne parla bene". Io in realtà, io ho un bellissimo ricordo, continuo a farlo sterore. È un errore che spero di fare ancora spesso. Io sono arrivato un po' in corsa e quindi volevo chiedere se anche la scrivere codice che genera codice fa parte della metaprogrammazione o no? In un certo senso è quello che fa. C'è però una distinzione che è importantissima. Non è un generatore di codice. Lo dico per due motivi. Prima di tutto perché non è un generatore di codice. e secondo perché generatore di codice tipicamente tutti li odiamo perché sono la tipica cosa che arrivi nell'azienda ed è rimasta scritta da quello prima che era scritto il generatore di codice che è, come si dice, è pacato fa la metà di quello che ti serve quando cerchi di uscire dai limiti non ci riesci quello che fa è generare l'equivalente di generare codice ma a runtime. Tu non vedrai mai il codice generato che è importantissimo anche perché un altro problema storico dei generatori di codice è che tu generi codice che è fisico e lì e poi viene versionato e poi qualcuno ci va a mettere le mani perché giustamente ci devi lavorare non ti puoi accontentare di quello che hai se il generatore non lo fa lo modifichi e poi se lo devi rigenerare non puoi e quindi diventa una liability continua. Hai questa roba che ti dà delle metriche terrificanti sulla build machine, nessuno la vuole toccare, non è fatto per gli umani ma gli umani ci devono lavorare. La metà programmazione è molto più impalpabile perché in realtà il codice, il tuo codice è tutto lì come se stessi programmando normalmente. In realtà, detto tra noi, lo spoiler è che la metà programmazione è un'etichetta che lascia un po' il tempo che trova, non esiste davvero, non c'è distinzione, ho ubi, tra la normale programmazione e la metà programmazione. Però ti devo fare un esempio concreto, se non sembra che stia parlando di filosofia. Allora, quando... l'esempio che ho fatto prima è, hai un metodo che prende le chiamate che non vengono gestite da altri metodi, ok? E ci fa qualcosa. Questo è un esempio banalissimo, comodo in in mille casi. Questo metodo è lì, tu lo vedi, non succede niente di magico, sembra magico finché non sai cosa sta succedendo e vedi sullo stack trace, come diceva Carmine dei nomi di metodi che non esistono nella classe ma quando capisci chi li gestisce quei nomi di metodi la magia si dissipa quindi è là non c'è un alto livello è la normale programmazione Ruby e in realtà quando tu programmi Ruby anche se non lo sai le sta usando queste feature del linguaggio io allora l'ho usata posso dirlo perché ho fatto ho usato l'aravel e il framework per diverso tempo ho fatto anche dei corsi anche in azienda e ho scoperto che questa cosa viene usata molto perché ci sono anche nel sistema di facade, ti chiami un metodo, lo cerchi in tutto il progetto quindi compleso anche tutte le dipendenze e non lo trovi. In realtà perché il metodo è formato dalla concatazione dal verbo e il modello del database e a un certo punto trovi quel metodo e dici "ah ma se viene chiamato uno di questi verbi, read qualcosa con un'entità che dipende dal tuo database, quindi possono essere post come user o qualcosa, allora esegui questa roba qua. E quando l'ho scoperto ho detto "ah, ecco come funziona" e vedi che tante volte dicono "guarda scrivi un metodo in una classe con questo nome, verrà chiamato dal framework in questa occasione" ma non trovi nessuna referenza di... è come se fosse codice offuscato, ma in realtà è offuscato dentro la documentazione, dentro il flusso deterministico del framework. Sì perché tu ti aspetti un'altra cosa, una volta che sai come funziona sai che l'assassino non ha i più problemi, è semplicemente un modo molto flessibile di scrivere molta roba con poco codice e lo testi, lo gestisci come normale codice. Quindi dico una parolaccia, documentazione. Attenzione a questa brutta parola perché può dare risultati ed potrebbe portare la verità alla luce. No, questo anche rispondo anch'io alla domanda, ovviamente l'ho fatta prima ancora di sapere che questo si chiamasse metaprogrammazione perché lo usavo già in PHP 5 forse con i metodi underscore underscore call underscore underscore method adesso non me lo ricordo nemmeno più e poi ho fatto anche alcune librerie framework in PHP. in javascript non lo so, può essere anche che l'abbia fatto, sì con i proxy probabilmente ho fatto qualcosa del genere, in php con uso e abuso di reflection, con un bazooka mi sono divertito abbastanza nello sparare mosche, però in realtà risolvevo il problema che in realtà è una figata perché tu risolvi un problema, lo risolvi anche in modo legato, ulteriori problemi escono fuori quando qualcuno vuole capire i giri che fa, oppure c'è appunto il famoso errore con la funzione che non esiste e uno deve capire e non tutti riescono, hanno tempo, voglia e sanità mentale di stare a seguire la fogliolina nel torrente, che si perdono. Un'altra cosa che mi è venuta in mente adesso, io adesso collaboro con un'azienda e c'era un ragazzo di 18-19 anni che stava smordonnando un po' su un'applicazione abbastanza complessa, registratori di cassa che comunicano con applicazioni Android, insomma una roba abbastanza complessa questo ragazzo era di prima leva, un junior, a un certo punto mi dicono "senti, dagli una mano" ok, cioè proprio non conosco nel dominio perché mi stavo occupando di un altro progetto, né C# né Android, insomma non era così, però ho detto "va bene dai, diamo una mano" e lui era proprio incappato in un sistema handmade di metaprogrammazione che costruiva da solo delle classi e lui non riusciva a trovare, dice "io ho questa classe ma non è istanziata da nessuna parte, so che devo intervenire lì ma non so perché e io ne devo creare un'altra e non so che come, non so cosa fare". Allora ci siamo messi lì a studiare insieme, vedi, vedi, vedi, guarda là, guarda là, insomma dopo una mezz'oretta siamo riusciti a capire qual era il rabbit hole, siamo scesi e guarda me lo scorderò mai, a un certo punto questo mi fa "oooooh" cioè sei lasciato con uno che è durato circa 15 secondi. La cosa bella è che ha detto che era una figata, non non era, non stava imprecando per dire "maledetti che cosa fate", magari nella sua ingenuità forse, però era proprio, ha avuto l'epifania e adesso io spero che gli abbia cambiato la vita. Guardate, va bene che c'è la programmazione, poi alla fine, a parte la soddisfazione intellettuale che c'è, ma è un vantaggio molto importante, molto banale, meno codice, ed è un trade-off spesso non si vede, non si nota, perché sai l'investimento di tempo che lui, per esempio questo tuo collega, lui non conosceva questa tecnica, queste tecniche e quindi all'inizio giustamente non ci capiva una mazza, non poteva, ha dovuto capire, ha dovuto chiedere aiuto. E' quello un investimento molto visibile di tempo. e l'investimento invece di navigare migliaia di getter e setter in una marea di classi superflue è quello un investimento che non noti. Avviene costantemente un po' alla volta per il resto dell'eternità fino alla morte termica dell'universo o all'estinzione del sistema, quello che succede prima, e tu non te ne rendi conto davvero, ma diciamo così, se un programmatore esperto che conosce i suoi polli, conosce queste tecniche, decide, sceglie di usare metaprogrammazione in un sistema, sta scommettendo sul fatto che l'investimento visibile e doloso sia alla fine più cheap di quello invisibile e costante e alla fine ti abitui perché certo è l'unico modo che hai per arrivare alla fine di questa catena di chiamate di metodi in C# è chiaro che devi attraversare uno stack di 60 chiamate è così che funzionano le cose ora a me piace anche C#, a me piace persino Java, lo dico senza vergogna ho sto fetish. Però ci sono le volte in cui poter bypassare questa complessità accidentale dà un gusto fisico e lo fai perché alla fine funziona e funziona bene. E' chiaramente una chiamata, una judgment call come si dice, una valutazione professionale. Si sa che noi programmatori abbiamo sempre la tendenza a prendere i giocattoli che abbiamo e usarli a sproposito perché soprattutto se scintillano godiamo quindi la programmazione la metà programmazione viene abusata però certe volte è utile davvero non è solo e tante volte utile davvero e poi domain in specific languages. Quella è l'altra applicazione che... Allora, guarda, ti faccio una domanda, senti tipo quelle cose che si possono chiedere da anni e... ah, da anni, anni, anni. Allora, perché questo tipo è un dibattito con cui mi ci... mi ci... mi ci devo spesso a ragionare. Non prendo in considerazione tutto quel tipo di metà programmazione che avviene a build time, quindi le macro praticamente. Perché tu lì investi il tempo nell'espandere la macro a compile time e dici ok, non mi interessa. Spesso, diciamo con persone magari che il più delle volte erano persone che non avevano ben compreso come funzionasse la cosa, un'obiezione che mi è sempre sembrata abbastanza legittima, alcuni non hanno mai saputo dare una vera risposta, era qual è il costo di performance della metà programmazione, quella fatta proprio a front-end, no? Perché ci sono stati casi, ad esempio, abbiamo avuto più di un problema quando lavoravamo su questo applicativo gigantesco, questo SaaS enorme, proprio flame graph alla mano, il problema lo abbiamo trovato all'interno di un'estensione di The Device che creava alcuni metodi a runtime, per chi faceva alcune assunzioni, faceva alcuni calcoli, tracciando che fosse stata scritta male, che non credo che sia sano tutto quello che hanno fatto con il modulo Crypt e tutte quelle cose che venivano fatte di continuo. Ma secondo te si può scrivere del codice performante utilizzando queste tecniche o è comunque un trade-off che si deve accettare? Diciamo che se hai scelto Ruby l'hai già accettato. Perché allora, per capirci, metaprogrammazione tu non puoi scegliere davvero di usarla. Ti faccio un altro esempio concreto. Io Ruby tutte le volte che chiami un metodo, tu puoi volendo definire un evento associato alla chiamata del metodo. questa è una funzione di metaprogrammazione ovviamente perché ti stai pluggando direttamente nel modello oggetti quindi tu dici sai che un po' che non la faccio sta roba quindi adesso spero di non dire stupidaggine perché mi ero pure dimenticato di dire però tu dici tutte le volte che questo metodo viene chiamato fai qualche segui questo pezzo di codice lo lo plughi. È un sistema di eventi direttamente nel modello oggetti. Oppure tutte le volte che questa classe viene istanziata scatena questo evento. Questo è un classico caso di metaprogrammazione perché ti stai attaccando lì all'interno del linguaggio mentre succede la roba e lo stai facendo, stai facendo delle cose. E' chiaro che costa, ma non solo costa se lo fai, costa anche se non lo fai. Perché questo implica che le chiamate a metodo non possono essere diretti non puoi semplicemente chiamare il metodo ci vuole qualcosa nell'interprete che guarda la chiamata e dice c'è qualche evento associato a questa cosa giusto quindi tu non non puoi fare alla cpp la chiamata e la chiamata aspetta il compilatore ha deciso di ottimizzare te lo metti in line non c'è neanche più la chiamata al metodo guarda perché spostare lo stack sulla cpu, cambiare il registro che costava troppo, lo metto in line, non puoi fare niente di tutto questo. Comunque è un overhead. Quindi tu stai scegliendo un linguaggio che è capace di fare queste cose. Fai già lento rispetto ad altri linguaggi, hai già fatto la tua scelta anche se non la usi. Quanto ti costa questo? è una scelta corretta? Che ne so dipende dal sistema che stai costruendo. Io in genere tendo a dire l'ottimizzazione prematura è il peggiore dei mali, prima farlo andare, vedi dove sono i colli di bottiglia, poi ottimizzi. Ho sentito che voi programmate in javascript, in php sono sicuro che mi capirete quando faccio questi ragionamenti. Però adesso se arriva uno che fa embedded ci manda a cagare tutti e cinque perché dice scusate, quattro scusate. Ho sempre avuto problemi con i numeri bassi. In realtà c'è sempre Mauro, quando lo chiami viene chiamato in automatico. Esatto. O è un problema di stima come per il libro, dice ma noi siamo quattro invece siamo cinque. Sento sempre a sovrastimare così sono tranquillo. e vi dicevo insomma se arriva uno che fa videogiochi dice ragazzi no lo so già che questa roba non va alla velocità non va a 60 frame al secondo sono domini diversi sono problemi diversi se hai scelto un linguaggio come ruby che non solo è dinamico e di alto livello ma lo rimane sempre comunque non rende facile come Python per esempio dire "aspetta che questo pezzo lo rifaccio in C", allora vuol dire che stai già risolvendo un problema per cui sai che le performance non sono così importanti, ottimizzi a posteriori e quindi in quel caso la metà programmazione è una feature, altrimenti diventa un bug. No no, guarda, è la risposta insomma che mi son dato e che ho dato anche io nel tempo, insomma ecco, alla fine è un compromesso come tutto. Allora io in realtà… Se posso ti interrompo, ti interrompo Carmine, ti racconto un aneddoto che dà un po' l'idea. Allora, a un certo punto nel linguaggio Ruby, Mats, Yukihiro Matsumoto, l'autore di Ruby, diciamo l'equivalente di Guido Farahossum, l'imperatore benevolo, il dittatore benevolo, decide di introdurre una nuova funzionalità, che tra l'altro a mio avviso è stata un fallimento, che si chiama Refinements. e questa funzionalità di Refinements permette di dire come la posso spiegare in parole povere permette di cambiare la definizione di una classe, di un metodo per esempio in uno specifico contesto per cui tu puoi dire io aggiungo un un metodo a questa classe ma solo in questo scope E questa cosa sembra che possa risolvere tutta una serie di problemi, per esempio il fatto che tu quando cambi un metodo a runtime poi hai la potenzialità di fare un casino biblico, ma se lo fai solo in uno scope limitato, anziché farlo globalmente, ovviamente vi rendete conto che diventa... come è definito? Cosa sarebbe uno scope in questo contesto? Tu dici proprio questo è un refinement, ora non lo ricordo più perché sono passati anni da quando ci ho guardato Da una classe in poi, tutte le sue sottoclassi o...? No, secondo me a livello... non mi insultate se lo sbaglio, ma mi pare che sia a livello di file in questo file questo metodo te lo ridefinisco, fa una cosa lievemente diversa ma al di fuori di questo file questo non succede tu dici "ma è pazzesco, ma questo è rottinio a Ruby" e l'alternativa è peggio, l'alternativa è farlo a livello globale cioè un file ti ridefinisce il metodo e tutti gli altri ignari si ritrovano al metodo ridefinito Io mi ricordo una cosa su Ruby, era non un tutorial, ma tanti anni fa, quindi non so nemmeno se è vero, che ti faceva vedere come te potevi riscrivere il più della matematica e stampare l'award, quindi facevi 2+2 e ti veniva l'award. Però era una cosa globale. Ora il refinement, sto guardando qui dalla documentazione, parla di moduli, è abbastanza onesto comunque. No, per dire, una volta che abbiamo tempo ti faccio una splendida demo, che era quella che facevo io di solito per spaventare la gente, in cui facevo un alias del metodo più, perché l'operazione più, come tutto in Ruby, è in realtà un metodo con il naso di gomma e zucchero sintattico per chiamare un metodo di nome più, ne facevo un alias, dopodiché ridefinivo il metodo più perché chiamasse quest'alias, ma due volte aggiungendo anche uno e se scrivi uno più uno fa tre, globalmente, in tutto il tutto. Happy debugging. Ecco i refinement sono fatti per ridurre questa forza, per mantenere sotto controllo queste feature e che poi sono stati ripeto un sostanziale fallimento. Ma la cosa interessante che vi volevo raccontare è che quando venne fuori questa cosa io feci un intervento su refactoring, su refinement ad una conferenza non mi ricordo dove, a Singapore mi pare e c'era Metz e c'era anche l'autore di JRuby che è l'implementazione di per java un interpretatore ubi che può girare sulle java virtual machine e lui mike disse si era inferocito perché diceva questa cosa ci ammazza a noi perché io sto girando sulle java virtual machine mi sta dicendo che tutte le chiamate a metodo io devo controllare su e giù per la catena dei delle sottoclassi se c'è un refinement da qualche parte. Mi stronchi la performance, ma me la stronchi proprio, io non riesco a farla sta cosa qua. E ne nacque una discussione tra le due anime della comunità, quella giapponese che diceva vai lento, fatti tuoi, e quella americana che diceva sì ma io non posso fare una cosa simile per cui azzoppo tutto il codice già esistente, già scritto per una feature che questo codice non usa neanche, praticamente c'è una barriera all'ingresso, un pagamento all'ingresso. Questo è un esempio di come l'esistenza stessa di alcune feature di metaprogrammazione comporti una penalità in termini di performance. Per questo ho fatto tutta questa sbordolata, Carmine. No, no, no, no, no, è interessante, sono cose interessantissime che a me hanno sempre affacciato più, diciamo, che per la parte intellettuale, insomma, oltre che la parte pratica, insomma, e a me piace perché ti dà proprio, ti senti veramente, ora per fare una citazione, un dio su piccola scala, ma qui lo sei su grandissima scala. Nel senso, da noi in questa vecchia azienda, noi colleghi, cioè c'è chi più di una volta ha fatto lo scherzone di ridefinire qualcosa di Active Support e fare GC Collect dentro, che è chiamare direttamente il Garbage Collector, che era una cosa infame. È un po' l'equivalente codice di quando si apriva il setup di Windows e si mettevano tutti i colori del desktop a Neo. Sì, esatto. Cioè, lo scherzo Caudel. Sì, sì, era una roba bruttissima. Ma alla fine, a fine senso, io credo che la bellezza di Ruby, io sono un grandissimo fan e credo che sia il modo più... oh, la so, ho perduto una cosa, prendo una marea di merda nei commenti, le migliaia di persone che stanno a sta puntata mi odieranno. Per me Ruby è il modo più elegante e umano di scrivere codice, proprio di scriverlo. Cioè scrivere codice Ruby per me è la cosa più vicina a ciò che posso capire, anche senza essere programmatore. cioè la standard library di Ruby è fatta per essere letta e per essere capita. Cioè non c'è niente da fare, cioè se io devo... ma anche su roba un po' più moderne, no? Chi ora vuole scrivere una filter o una map in PHP, ad esempio, ora ci siamo arrivati ad avere una firma più o meno che si capisce. ma fino a qualche persona fa stavamo ancora con il parametro needle e il parametro haystack, cioè proprio ok. Quindi il fatto che comunque potevi scrivere anche 15 anni fa del codice che si capiva, io prendo una lista e ci chiamo includes, col punto di domanda, cioè è una roba bellissima. Cioè, è ciò che può essere capito. A me ciò che ha sempre affascinato era anche la possibilità di poter far coesistere un'anima ad oggetti con un'anima anche un po' più funzionale, che poi è quello insomma che sto rifacendo oggi. Era una roba pazzesca. Oggi lo fanno un po' tutti, sì. Si si si si, si si. Si si. L'inguaggio che è introdotto, questa idea senza nulla togliere poi è sempre... No no no, ma assolutamente, ma anche se prendiamo Rails, Laravel è il Rails del PHP, Phoenix è il Rails di Elixir, Django è il Rails di Python. Cioè, cioè nel senso ora possiamo fare una puntata intera su DHH, su Rails, su quello che vogliamo, ma le idee sono... Le idee vengono da lì, è vero. Le idee vengono da lì. Io mi ricordo che la prima volta che ho utilizzato un'alba e l'ho detto "cazzo, adesso è Rails". Cioè nel senso non c'era... Io ho una mia teoria personale per cui in ogni momento nella storia della programmazione c'è un posto, una comunità, un linguaggio e così via da dove vengono le idee che poi vengono, si spargono e adesso sembra impossibile a voi forse sembra assurdo ma a un certo punto è stato Java intorno alla fine degli anni '90 perché il test driven development, il stesso il unit testing e tutte queste cose qua si sono diffuse, i refactoring si sono diffuse lì poi è stato Ruby, poi ad un certo punto è diventato JavaScript e lì io mi sono sganciato perché JavaScript non è nelle mie corde però è stato il posto dove si inventava, dove si facevano gli esperimenti, anche falliti, però era lì che succedeva e era Ubi per parecchi anni è stato quello, il posto dove si facevano gli esperimenti. LM: E poi è una ruota che gira, si dimentica che questi esperimenti che facciamo in realtà li hanno già fatti cent'anni fa. GZ: Si, per quello che li ha fatti prima, si assolutamente, però c'è un momento in cui vengono applicati su grande scala. Non lo so, il concetto in javascript di "aspetta vediamo che succede se ogni cosa diventa una libreria" "ah ma queste due righe di codice, fa la libreria" è un'idea secondo me fuori di testa, nel senso non penso che sia una buona idea, ma è bello sapere che ci hanno provato, che l'hanno fatto per un periodo capito, poi alla fine le idee che funzionano scopri sempre qualcuno che lo faceva negli anni 60, è quasi una legge della programmazione, però fatto stare che è stato lì che è diventato popolare questo concetto e sì, come come dici tu Carmine, Reiza ha introdotto un sacco di idee che oggi vengono date per scontate e il bello è che molte di queste non sono così ovvie, per esempio il concetto di Convention Over Configuration, che oggi è talmente ovvio che è diventato invisibile. Cioè, nessuno si ricorda di quando, non lo so, io nel mondo Java, a un certo punto ero nel team di Hibernate, esiste ancora Hibernate? Dite, ma lo voglio, il Map, ok. Purtroppo sì, sì. Vuole scoprire se lavoriamo in Java. Non ho idea. No, no, no. voglio solo sapere se esiste io credo di sì, credo sia una di quelle cose che chi le ha fatto esatto, il COBOL e io mi ricordo la sofferenza per fare delle cose ovvie perché ogni cosa dovevi configurarla possibilmente, se possibile, con cento righe di XML che seguivano un determinato schema e questa cosa finì con Rails. L'idea di, scusate se una cosa è il default perché te la devo dire, che oggi sembra, beh non c'è neanche bisogno di parlarne, ovviamente si fa così, non era ovvio nel 2005. E' diventato ovvio con Rails. Io mi ricordo esattamente convention over configuration, lo associavo a Rails perché per un piccolo periodo durante l'università feci una sostituzione e non avevo idea di cosa volesse dire, poi ho detto "ah ok, non devo diglielo per forza perché c'è il default" però è lì la prima volta che l'ho visto. Ora invece è molto più comune e non lo chiami nemmeno più così. Non lo chiami nemmeno più così perché è ovvio, è il modo di oggi di fare le cose. Un altro esempio che ti posso fare è ancora più fine, è un approccio quasi filosofico e l'idea che se tu usi un framework ovviamente questo framework ti deve risolvere i casi normali l'ottanta per cento se hai un caso sfigato ma mettiti i guanti da da veterinario e vai te lo scrivi. No pure noi in in platformatica abbiamo fatto una cosa simile, cioè facciamo delle API, leggiamo lo schema e ti si dà le API REST come fa Asura per leggere e scrivere, ma se ti ha bisogno di join ti si dà la funzione per dire esegui questa query e la query la scrivi te, ma intanto l'avresti scritta ugualmente perché non usi framework, datamapper eccetera per quelle cose complesse, per le cose semplici ce le hai già pronte. Questi sono concetti che sembrano talmente naturali che uno dice ma non è possibile, sempre esistiti. E' chiaro, ma non sono sempre esistiti. Vi faccio, vi do un altro bell'aneddoto, non mi dire che adesso sto cercando di portarvi verso il lato oscuro, ma anche questo riguarda Java e Ibernet. Nel team di Ibernet a un certo punto io avevo scritto un pezzo di Reflection, sempre stato interessato in queste cose un po' sporche, quindi in qualche modo tipo metaprogrammazione, e il il leader del progetto mi disse senti abbiamo un problema abbiamo c'è stato uno che ha scritto sui forum a lavore in una grossa azienda e ha detto che il setup del sistema è lento ci mette due secondi ad andare su il sistema quando lo lanciano e dice no non è possibile non è vero cioè non può come fa a metterci due secondi scusa sono quattro chiamate in croce fa un po di reflection sulle classi del database e sì ma questi sai questi hanno non mi ricordo quante decine di migliaia di classi del database non può essere decine di migliaia di classi del database vuol dire che hanno decine di migliaia di tabelle nel database cioè non esiste una cosa così brutta nell'universo imploderebbe. No no esiste, loro hanno decine, un database con decine di migliaia di tabelle e le classi e ci mettono dei secondi a tirare sul sistema. Beh io ho risposto come risponderebbe chiunque oggi, abbandoniamoli lì, sono morti, cioè non meritano la nostra pietà. voglio dire non possiamo fare niente per questa gente e lui risposse me lo ricorderò sempre no noi dobbiamo risolvere questo caso perché un caso legittimo è un caso d'uso noi dobbiamo risolvere il 100% dei casi d'uso questo concetto oggi è inconcepibile è chiaro che se ha un caso d'uso spiegato che hai solo tu nel mondo guanti da veterinario e giù con l'elmetto laminatore All'epoca questa cosa non c'era. Queste sono cose che sono nate con Ubi, con Javascript. Bellissimo comunque l'enfasi che è stata messa e anche il tempo su questo caso d'uso. E poi dopo abbiamo parlato di un programmatore che è in carcere, che aveva collegamenti con Assange così in tre secondi. Ora vi racconto una cosa, mi è venuta pure la voce da True Crime, adesso è un caso proprio bellissimo. No, no, allora guarda, innanzitutto devo dire che quando ho detto prima i refinement, mi è successa una cosa, ho detto "aspetta, aspetta". Quindi sono andato sulla mail a riprendere questo biglietto, perché faccio proprio inversione gruppi, io ero nel 2016 a Firenze al Ruby Day a vedere quel talk, nel senso quindi questa roba... Non c'è grado. Ma proprio fatto così, ho detto "ah, aspetta". A quanto pare non mi ricordo, perché non mi ricordo neanche bene come funzionava il refinement. No, però giusto così, all'altra di questa diversità, io l'ho sempre avuta questa sensazione per Ruby e per Synger, ma a questo punto ti faccio una domanda anche un po' all'altra. Io ho visto, in realtà, ho alcune persone che hanno seguito alcuni tuoi corsi online su Git. In questo momento ti faccio proprio la domanda così, ma quando scrivi un libro tecnico, lo usi anche Git? Cioè, nel senso, un sacco, ne conosco tantissimi, però alcune persone che hanno contribuito ad alcuni tipi di... "Ah, cazzo, con Git è molto più semplice collaborare al libro". Io non ho usato Git per nient'altro che non sia codice, ma anche i blog posti però è giusto una cosa così. Si può usare, cioè lo usi Kit per scrivere il libro, si può usare e lo usi al suo potenziale o semplicemente fai commit e lo butti così, giusto così? Lo uso, lo uso. Lo fanno. Lo uso, allora, senti, dunque, lo uso perché lavoro con una casa editorice fondata da programmatori, lavora con programmatori che scrivono libri di programmazione quindi loro sono stati, che io sappia, sicuramente c'è stato qualcun altro, ma che io sappia tra le case editrici che conosco, i primissimi, anni prima rispetto agli altri, a costruire un sistema di build per i libri. Per cui tu scrivi libri con un markup che prima era xml adesso può essere markdown e c'è una build machine che ti costruisce il mobile pdf e l'ipub e così via e questo vuol dire che il sorgente del libro è testo Ora credo che lo facciano davvero tutti, perché fino a quando iniziai a fare questa cosa, le altre case di italici ancora ti chiedevano il file word e tra l'altro chiedevano all'autore di formatarlo, per cui a decidere dove andava il grassetto e dove andava l'italica era l'autore, cosa che non ha senso a mio avviso. Io come autore dovrei lavorare a livello semantico, dovrei dire questa è una cosa da mettere in rilievo, poi sei tu che fai la fotocomposizione, che fai la grafica, decidere come metterla in rilievo no? Quella è una questione. E adesso infatti lo fanno tutti. Un'altra caselettrice che mi ricordo che era all'avanguardia in questo senso era il mulino di Bologna, una casellettrice di libri famosa nel campo dei libri accademici e che usava Subversion nel loro caso, ma ovviamente erano limitati come molti dal fatto che se tu hai default binari, come hai detto tu, Git, Subversion o quello che è i sistemi di versionamento li puoi usare al minimo, puoi fare con MIT, ecco, puoi tornare indietro se ti sbaglia a un HANDU, sono dei grossi HANDU, mentre invece con loro si può usare git per bene. E' chiaro che l'esigenza di usare git è minore per un libro rispetto al codice, perché non fai diff debugging per esempio, però ogni tanto scopri di aver cancellato qualcosa che ti serviva, allora torni indietro, recuperi, fai un confronto per vedere cosa hai scritto quando. No, no, lo uso bene. Usi cose tipo Asciidoctor? Asciidoc che parlavi? No, era un'altra roba. Ok. Ma perché ho usato per altre cose, in generale per generare documentazione appunto Asciidoctor, però mi ricordo che può essere usato anche per generare pub e cose di No, uno use case classico è il fatto che per esempio adesso questo libro su machine learning che ho scritto c'è dentro tanto codice e un problema storico dei libri di programmazione è che il codice è rotto. È difficilissimo mettere il codice in un documento e tenerlo funzionante. Tipicamente il codice è rotto già dalla prima edizione del libro. mentre lì il codice è in file, per esempio in questo caso è Python, ci sono i file Python che io lancio, li testo, ci sono gli unit tests dove si può, è machine learning quindi poco ma... e poi vengono incorporati nel libro nel momento in cui fai la build, quindi quello è un vantaggio enorme per i libri tecnici. e quindi a questo punto non posso far altro che chiederti, tanto era già in programma nella nostra scletta che non c'è. Ma come, diciamo, poi ti sei cominciato a interessare di Machine Learning, come è nato questo libro sul Machine Learning, insomma, e come è fare le cose in Python rispetto a Ruby? Allora, guarda Carmine, il libro è nato nello stesso modo di quell'altro, mi piaceva la cosa, volevo imparare, poi mi gaso, poi dico "aspetta che ci scrivo un libro, così imparo davvero bene". Parto sempre dalla famosa formula per cui io vorrei un libro così, esattamente così, perché poi è un po' ossessivo compulsivo, come molti di noi, quindi lo voglio così. però non c'è, aspetta che me lo scrivo, se lo voglio io lo vorranno anche gli altri che non è vero di solito, non è necessario, magari lo voglio solo io per esempio la comunità del machine learning cerca un'impostazione molto diversa da quella dei programmatori io infatti ho scritto un libro sul machine learning per programmatori e quindi mi metto a scrivere metto a scrivere il libro sul machine learning python perché insomma uno deve andare deve prendere la direzione di minima resistenza e il linguaggio del machine learning è python che tra l'altro è un bellissimo linguaggio quindi non è da dire "ah sto soffrendo" è bello. Com'era i spettrorubi? Beh allora sono separati alla nascita si somigliano moltissimo però ovviamente nel momento in cui va in profondità cambia molto perché per esempio la metà programmazione in python è molto meno flessibile molto meno naturale che ruby. La sintassi di python è in qualche modo polarmente opposta a quella sia quella di ruby nel senso che ruby è il massimo della flessibilità e all'inizio ti domandi perché infatti chi si avvicina a Ruby dice cazzo mettetevi d'accordo questa cosa che io quando chiamo un metodo anche quando lo definisco posso usare le parentesi o non usarle. Che senso ha? Combini è solo casino. Dammene uno e sceglilo. In realtà la questione è che questa scelta ti permette di essere molto più flessibile se fai un domain specific language. E questo il motivo per cui non solo Rake che è una libreria di Ruby per fare le build sembra un linguaggio specifico per fare le build perché la sintassi è flessibile la modifichi come ti pare Rails Active Record sembra un linguaggio specifico di dominio per fare le query del database e Python questa cosa non ce l'ha perché lui ha una sintassi molto rigida anzi per essere un linguaggio dinamico l'esempio classico è il whitespace significativo, cioè se tu non indenti come interprete comanda quello non gira. Però d'altra parte questa rigidità l'ha reso molto popolare tra gente che programma tutti i giorni ma non si considera programmatore di mestiere, per esempio i data scientist. Inoltre ha un'integrazione con il C fantastica che gli permette di fare uno strato gradevole da vedere e da usare su un mare di librerie complesse tecniche scritte in C dura pura e quindi di conseguenza poi alla fine si è posto giustamente va bene come usare python se sta facendo machine learning è fantastico se dovessi scrivermi uno script un programmino per conto mio un'applicazione china per me userei comunque ruby ma python è un bellissimo linguaggio diciamo che una volta che entri nell'ottica non si può, sarebbe ingeneroso da parte mia dire che non ho provato piacere. Ci puoi fare metà programmazione in python? Lo dico da ignorante, sei un ignorante in materia? No, guarda, sono un po' ignorante anche io, si lo puoi fare, che io sappia, un po' più limitata, però se vuoi fare queste cose tipo definirti il metodo runtime, fare il metodo a chiappa tutto, queste le puoi fare. La questione che non ha un modello oggetti coerente come quello di Ruby, quindi non ti dà lo stesso brivido intellettuale di capire la metà programmazione Ruby. Ci sono altre cose? Scusa, vai. No, no, no, stavo pensando che adesso hai detto che nel libro sei rivolto un po' più programmatori di machine learning e mi immaginavo che in questo caso secondo correntemente tutto quello che abbiamo detto che hai detto potrebbe in questo caso la metà programmazione potrebbe agevolare e togliere parecchi layer di complessità per fare quelle quelle cose e concentrarsi un po' di più sul concetto, sulle cose del machine learning. Ma tu l'hai mai visto i programmi scritti dai data scientist? No, no, no, per carità ma li posso immaginare, io ho visto di tutto e di più, specie ultimamente, ma appunto, forse eliminando certe complessità in modo che possano scrivere meno metodi e meno comode. Non è una preoccupazione di solito, sono 4 incroci, che fanno cose complicatissime, difficilissime, ma il codice è semplicissimo. Cioè la complessità non è nel codice in quel caso. Tanto per darti un'idea, io ancora vengo mandato a cagare con eleganza dai data scientist quando faccio loro notare che non è bello che i due terzi della roba che scarico da github di machine learning semplicemente non giri perché loro non hanno il concetto di dire che ne so quale versione di una libreria stanno usando un problema risolto in informatica ma loro non se ne preoccupano come quale versione. Usi NANPAI. Sì, ma NANPAI è lì da decenni e sono tantissimi. Non gira, sai, chiamo un metodo che non esiste. Quale versione? Ah boh, l'ultima. Non è il loro lavoro. Il loro lavoro è un altro, molto difficile, ma non è questo. Di questo non gliene frega niente. Figurati di scrivere il codice elegante. Già di scrivere il codice che gira se ne preoccupa relativamente. Ma in realtà questo è un concetto a cui sto pensando proprio recentemente, il fatto che nel mondo informatico esistono tante persone che non sono programmatori ma che fanno i programmatori per virtù e per necessità, perché hanno un problema molto specifico da risolvere nel caso di Data Scientist, quindi di allenare qualcuno, di creare qualche modello e hanno le capacità per scrivere codice ma ovviamente non del buon codice. Ma questo non succede solo con i Data Scientist, è successo parecchio per esempio col PHP, motivo per cui il PHP ha la nomea che ha, ha, in parte, però io credo anche che ci dobbiamo risolverla, questa situazione, che non è soltanto ovviamente biasimare o cercare di lottare contro i mulini a vento, perché alla fine non è il loro lavoro, a parte invertite probabilmente faremo lo stesso, diremmo lo stesso, diciamo "guarda, questa cosa mi risolve il problema, arrangiati te sulla bellezza". Però è un concetto, è una roba che da un po' ci sto pensando che in qualche modo la dobbiamo risolvere perché esistono. Questi sono problemi culturali, la cultura si debaglia malissimo e tendenzialmente i cambiamenti sono molto lenti. Non sto dicendo di non provarci, io ci ho provato, per carità ho cercato un po di... è difficile tanto per darti un'idea tu sai che uno degli strumenti più usati nel campo del machine learning è Jupiter notebooks più o meno sapete come funziona no? sono... diciamo barrizzato su ste pagine web con del codice dentro e tu lo fai girare ovviamente il sorgente di un Jupiter notebook se tu lo apri in formato testuale, tanto per dirne una, c'è dentro tutto insieme il codice, la formatazione e l'output del codice, perché di solito l'idea lo fai girare, questo ti stampa una tabella con i numerini dentro e tu la salvi. Puoi immaginare la gioia la felicità di mettere questa roba in un sistema di versionamento dove il diff diventa di fatto impraticabile e devi riversionare tutto ogni volta e è appena un gradino sotto versionare dei binari e cercare di capirci qualcosa dopo a posteriore e a un certo punto tu gli dici vabbè ragazzi non deve essere non può essere un problema così difficile usare questa cosa che capisco che per voi sia importante perché voi scrivete una riga di codice per spiegarla ci vogliono tre paragrafi di linguaggio naturale con tutte le citazioni dei paper per carità mettili là poi quando lo devi far girare effettivamente prendi il codice del Jupyter Notebook, lo copie e incolli alla maniera di minonno all'interno di un file python e lo fai girare. No no, questi cercano di mettere Jupyter Notebook in produzione, con il dolore che ti puoi immaginare di conseguenza e gli ingegneri che ovviamente elevano dei peana alle divinità egizie. E sono passati anni prima che capissero quello che si vedeva a occhio nudo che se mette un Jupiter notebook in produzione tipicamente esplode. Perché? Perché non è il loro lavoro. E' lo stesso motivo per cui io se buco una gomma chiamo l'assistenza che faccio il pilota io. Per me la macchina è lì perché mi è utile ma non mi riferisco a niente. - Senti, come pubblicare degli appunti, faccio degli appunti e dico "ok, questo è il libro" per ritornare alla fase di prima. No, gli appunti vengono ritrovati e lo dice "guarda, facciamo un libro a partire da questi perché..." Sì, e loro non si rendono conto ovviamente della quantità di lavoro che va in questa tradizione, no? Quindi sta nascendo una figura proprio che loro considerano un po' lumpa-lumpa del poveraccio che prende la roba venuta fuori da Data Scientist e la deofusca e la mette in una forma adatta. Sì, tipo il farmacista che prende la ricetta fa "ah ok" e ti dà effettivamente la scatolina per prenderla. Però quello che c'è scritto è... Ecco l'analogia con la grafia dei medici è azzeccata. Ma che poi io mi sono sempre chiesto questo, qui si può fare una puntata a parte, se vuoi la facciamo. Ma a me, io voglio capire le cose ed è uno dei motivi per cui ad esempio tutto il tema del machine learning, non mi ci sono mai avvicinato perché sono una persona che vuole andare bottom up nelle cose. Quindi Io mi dico, va bene, io non ho quel background, quel background matematico, ho fatto tipo analisi 2 sei volte, cioè nel senso, proprio sono quel tipo di persona, e dico, ok, non ho quel background lì, e quindi non mi ci avvicino nemmeno, anche se ho sempre avuto una forte curiosità per quella roba. E vedo che dal punto di vista proprio del programmatore, di chi scrive software, Cioè, nel senso, sono veramente, sto 200 righe, dici "Boh, ma che cazzo è sta roba?" Che è una cosa che a me dà proprio un fastidio qui dietro, con questi numeri messi così. Tu dici "Che cos'è questo numero? Lo so io". E 15. Dici "Boh, che cazzo è?" Cioè, è proprio una roba che non mi riesco a spiegare. Secondo te, per uno, per un pro... qual è il percorso, la strada più semplice da correre? Per un programmatore che scrive codice e gli piace scrivere codice, dare un occhio anche a quella roba lì, senza impazzire. Compra il libro mio, no? Piratalo, poi se ti piace te lo compri. Leggitelo, poi se ti piace te lo compri. Se no, lasci stare. Guarda, è fatto per quello, è fatto esattamente per questo scopo, cioè non è, non ti insegna usare il machine learning, perché non te lo posso insegnare, non lo so usare, ti insegna quali sono le basi, per quale motivo questa cosa magica funziona e a un certo punto c'è un programma in Python che se tu lo compatti, ho una presentazione su quello on stage, a un certo punto ho detto ragazzi togliamo tutto quello che non serve a costo di offuscarlo. Lo compatto sono 13 righe scritte da zero e fa riconoscimento di caratteri senza libreria di machine learning niente lo fa da l'unica libreria che usa è NumPy per fare moltiplicazione di matrici ha detto analisi 2 quello è geometria ok algebra di base moltiplicazione di matrice l'unica libreria che usa e per il resto funziona per riconoscere i caratteri con notevole accuratezza, caratteristiche a mano, e sotto alle dieci righe. E un terzo del libro spiega queste tredici righe. E alla fine ti prometto che le capisci. Mi faccio sta pubblicità. Guarda, non ho niente di un certo. Assolutamente. Guarda. No, no, no, anzito. Fai bene, nel senso mai convinto lo prendo. Nel senso... Prima lo piratiamo e poi lo contempo. Se ti piace è chiaro, non è che lo compri a scala più. Hai detto una cosa interessante, suona non c'entra un cazzo, ma come funziona da autore del libro con la copia pirata? Cioè a me questa è sempre una roba che mi fa piacere. Quelli che ci fanno molti soldi magari se ne preoccupano, a me che mi cambia, mi conferma copia o non mi conferma copia. non sarà quello che mi cambia il mutuo, è chiaro che mi fa piacere se vende una copia in più, ma mi fa anche piacere se qualcuno legge qualcosa di mio e gli piace, quindi non... No, no, no, assolutamente. assolutamente. Senti, a questo punto sono un'ora e venti, ventidue, ti stiamo trattenendo tantissimo. Possiamo passare, se hai qualche cosa per noi, al Paese dei Balocchi, ok? Che è sostanzialmente questo momento in cui gli ospiti e anche noi consigliamo qualche cosa alla computatore che possa essere, diciamo, inerente o meno alla puntata. Io non dico metaprogramming ruby perché, nel senso, non voglio togliere, però in realtà l'ho consigliato che do 6-7 puntate, però va bene. Inerente o meno può essere una nerdata a scelta. Assolutamente, assolutamente. Allora, sto guardando la mia libreria qui dietro. c'è un'azienda giapponese che si chiama Hanayama che produce puzzle meccanici un paio qua guardate che tipo di roba purtroppo questo è un podcast quindi lo posso far vedere solo a voi sono oggettini così i classici puzzle meccanici che devi cercare di risolvere ok? Hanayama ne hanno tanti ne hanno tantissimi una linea grande, categorizzati da difficoltà 1, che sono praticamente la cosa che la prendi e spesso la risolvi in due o tre secondi, ed è più l'eleganza meccanica dell'oggetto che la sfida, a difficoltà 6 che ci promette i mesi a stare lì a spippolare, a cercare di muoverli. Ogni tanto io mi metto lì, anche se non non ho tanta pazienza per gli oggetti meccanici, mi piacciono i bit, però questi sono gratificanti anche perché sono tutti diversi, alcuni sono di metallo lucente, altri brownito, altri multicolore, hanno anche una loro estetica e sono bellissimi, è l'unica collezione che faccio, io non sono un collezionista proprio come istinto, però questi me li compro perché In realtà puoi farmi vedere perché mi sa che questo video va anche su YouTube. Si va anche su YouTube. Ma quindi è una collezione nel senso che ogni tanto escono nuovi oggetti? Ogni tanto ne pubblicano di nuovi. Guarda, guarda un po'. Questo, vedi? Questo che sembra una stella marina con un pescetto dentro e devi liberare il pescetto dalla stella. questo che è una specie di gabbia con dentro un Questo oggetto spinoso lo devi spilare. Sono così oggetti fisici che a volte Diciamo che impegnano il cervello in un modo diverso A volte può essere rilassante perché il lavoro è risolvendo problemi stessi artificiali. È come suonare uno strumento, come a volte si dà agli animali dei giochi di cervello per farli stancare o per farli distrarre. Perché è anche noi uguali, invece di incaponirci fino alle due di notte su un problema, dicendo "mi stacco, faccio quello" e poi la mattina dopo ho risolto. C'è problemi che non tocchi e che non esistono. Esatto, esatto. Qualcosa che si tocca. Vi propongo questo come giocato. Ok, perfetto. Voi ragazzi? Allora, io visto che l'avevo detto prima e poi non faceva parte della metà programmazione, però segnalo questa libreria per Node.js, si chiama Code Block Writer, che vi aiuta nel scrivere un programma che scrive un file JavaScript, quindi si occupa di indentazione, blocchi, eccetera, eccetera, per cui noi in Platformatic lo usiamo perché generiamo, su richiesta dell'utente con una command line, dei client per interagire con delle API definite da OpenAPI, quindi scriviamo tutti i metodi che sono definiti in OpenAPI come metodi JavaScript o TypeScript. È una cosa che diventa in effetti abbastanza complessa, però aiuta molto nell'avere poi un file che è ordinato, cioè che è indentato bene, quantomeno, senza dover per forza sapere in che punto di indentazione lei ci pensa dove siamo, a Codeblock Writer, le trovate nella nota dell'episodio. Io vado, l'avevo citato prima, non so quanto è conosciuto, quanto no, però l'ho usato, quindi mi è venuto in mente, lo dico, è proprio Ashi Doctor, che è appunto un programmino scritto in Ruby, tra l'altro, che ti genera da markdown, ti può generare tutti gli effetti, HTML, libri, credo anche pub e cose di questo tipo e qui mi è venuto in mente perché l'abbiamo usato per redigere la documentazione di Alpenbits e lì abbiamo usato la tecnica per cui i file di codice di XML erano interi e poi venivano, erano file proprio appunto XML che poi venivano presi parzialmente direttamente nella documentazione, quindi lì, quello l'avevo fatto io, facevo girare i test di validazione sui xml contro i csd così eravamo sicuri che quello che rilasciavamo era testato, perché dopo quattro volte che rilasciavamo cose non buone abbiamo imparato e quindi l'abbiamo fatto. Come seconda cosa, qualcosa da toccare con mano e che un invito questo, ragazzi, compratevi una penna stilografica, un diario e scrivete. Io ne ho comprate due e penso che me ne comprerò ancora una decina perché mi viene proprio voglia di scrivere. Bravo Carmine, fa vedere la sua, mi sembra che è la stessa che ho preso. E non lo so, ho ripreso il gusto di scrivere e lascio anche qualcosa ai posteri perché poi tutto quello che scriviamo sui computer chissà chi ne farà, sarà dimenticato in qualche backup, in qualche hard disk che nessuno mai leggerà. Quindi questo è più un invito. Le mie due cose sono i due libri di Paolo, quindi "Edda a programmi rubi" che ho consigliato infinite volte e "Programming Machine Learning". Carlo prendete "Programmi Rubi" perché se lo trovate cartaceo, prendetelo cartaceo, perché i libri di quella collana sono scritti veramente bene. È un piacere toccarlo con mano. Ok, questo è. Quindi, non voglio trattenervi oltre, come dice Mauro, io faccio le veci di Mauro, da questo momento in poi anche Gitbar è casa tua, se vuoi ritornare a parlarci di qualcosa, saremo felicissimi di averti qui. vi ricordo i nostri contatti @brerepo su Twitter, info@gitbar.it se ci volete scrivere una più tradizionale email. Il fax ci stiamo attrezzando e vi invitiamo ad entrare nel nostro gruppo Telegram, potete cercare Gitbar sul vostro client di Telegram preferito, siamo più di 1500. E detto questo, io saluto Paolo, saluto Luca, saluto Leo. Ciao, è stato un vero piacere. vi siete ascoltati tutti io che vi ho sparato senza battere. È stato bellissimo parlare così poco. Sì, infatti, hai una voce da radio. Io farei una voce da radio, farei sta serie Gitbar ASMR con Paolo Perrotta. Midnight Rent. A mezzanotte mentre uno dorme dal turno di notte e ti senti RENT, tutti i 1500 che dormono, beati! Perfetto, va bene! Ciao a tutti! Ciao ciao! E vi chiamo le sigle perché mi abbiamo capito! Ciao! [Risate]