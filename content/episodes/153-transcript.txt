Un tossisco sullo schermo vado a riempire la bollaccia ma poi partirei ci sono bene e benvenuti su GITBAR, nuova settimana e nuovo episodio qua nel nostro bar degli sviluppatori sono le 9.46 e stiamo registrando sempre sempre più tardi ma comunque GITBAR resiste e ogni settimana arriva nei vostri lettori di podcast mi raccomando www.newpodcastapps.com per trovare un lettore di podcast indipendente oltre al classico Spotify forse anche il caso di utilizzare un podcast reader che supporti bene tutte le feature e che in qualche modo non ci ci deleghi, non ci intrappoli nel contesto di Spotify Benvenuti su Gitbar, il podcast dedicato al mondo dei fullstack developer, i mezzo artigiani, i mezzo artisti, che ogni giorno infilano le mani nel fango per creare nel modo più efficiente possibile quei prodotti digitali che quotidianamente usiamo. [Musica] E' arrivato il momento di presentare i due ospiti di oggi. Uno è una conoscenza ormai sedimentata di Githbar, nonché un mio caro amico, e un altro una conoscenza abbastanza nuova di Githbar, è la prima volta che lo sentite qua, ma anche lui è una persona che stimo tantissimo abbiamo con noi Paolo Insonia e Marco Ippolito. Ciao ragazzi! Ciao a tutti! Piccola introduzione giusto per capire chi siete. Allora Paolo è uno staff engineer a NearForm, ormai stasera Githbar è un po' casa NearForm, siamo tre NearFormer che registriamo e non è sponsorizzato questo episodio lo dico subito quindi possiamo dire tutto il contrario. Paolo dicevo è staff engineer a NearForm e anche una delle persone di Diamante del DevRel Team. Marco invece è un software engineer a NearForm e anche lui uno dei membri del DevRel Team di NearForm, dico giusto? sì dici bene dal primo aprile sarò ufficialmente nel team di developer experience di Mirfoil. ok Marco ha subito sottolineato una mia incorrettezza io ho detto devrel team perché questo periodo ce l'ho in testa ma in realtà si tratta di un team di developer experience, ve ne ho parlato più di una volta di questo team qui ai microfoni di github ma oggi li ho invitati per raccontarci una storia. Voi lo sapete a github non raccontiamo spesso storie, esperienze e percorsi di carriera però dicevo ho voluto apportare questa esperienza personale questo percorso personale perché ho osservato un momento particolare di questo percorso che in qualche modo era la partenza e poi con assoluto piacere ho visto come si è evoluto, però io sono una vecchia, avete presente le vecchie che stanno alla finestra e che devono sapere tutto di tutti, a me mi mancano i passi intermedi, per cui sono qua a chiederveli. Iniziamo la storia. Molti di voi hanno sentito di Alicante perché nella puntata con Michele ne abbiamo parlato, praticamente abbiamo fatto un'ora e mezza dove parlavamo della nostra esperienza ad Alicante e proprio ad Alicante durante un giro in bicicletta io ricordo chiaramente una frase di Marco che diceva "oh raga io ho voglia di fare qualcosa di figo, tiratemi fuori qualcosa di figo e poi vedi Paolo che disse tranquillo prepara il culo sulla sedia perché ci penso io ti devasto da quel punto in nulla fino a raggiungimento cioè in nulla io non ho più visto niente fino a raggiungimento però di un traguardo che dal mio punto di vista da osservatore esterno è un traguardo importante per il quale io faccio i complimenti a Marco e per il quale poi ne parleremo, però voglio che in qualche modo mi raccontiate cos'è successo dopo quel "preparati perché ti devasto". Vai Marco, lasciati la parola. Come un po' tutte le grandi storie si inizia da uno scherzo, così da una battuta. Io ero sempre interessato al nodo, al soccorso, ai funzionamenti, però vedevo questo progetto enorme, molto complesso, a cui non avrei saputo come approcciarmi in nessun modo. Allora, così, scherzando, visto che Paolo è uno contributori che abbiamo in nier form. Ho detto dai ci vorrei provare anch'io, cioè vorrei fare anch'io qualcosa di figo, allora glielo ho lanciato, gli ho detto così dai fammi partecipare anche a me e mai avrei sospettato che poi sarebbe andata a finire così. All'inizio è stato uno scherzo poi effettivamente mi sono messo lì sulla prima issue e ci ho messo una settimana per scrivere tre righe di codice e poi piano piano grazie a Paolo, grazie a tutte le issue che lui mi consigliava e al lavoro insomma ho acquisito familiarità con il progetto e sono stato nominato, quindi è stato un percorso abbastanza lungo, comunque ci sono voluti circa sette mesi, sei-sette mesi. È stato anche un percorso duro, cioè, di contribuzioni costanti fino a sera tardi, il sabato e la domenica, però mi sono divertito, è stato di Vestè. Giusto per fare chiarezza ormai l'hai spoilerato quindi possiamo dirlo il ruolo che poi alla fine di questo percorso di sette mesi che ha fatto è stato quello di core collaborator su node.js. Correggetemi se sbaglio potrei fare strafalcioni. Dal momento in cui Paolo ha sentito la tua disponibilità. Tu Paolo, come ti sei mosso? Perché trasformare un'offerta da una parte, una disponibilità che è da una parte un'offerta, io ci sono, ma dall'altra anche una grossa richiesta d'aiuto, guidami per favore, a livello pratico, come si pone un mentor all'inizio di questo percorso? ma il punto è... allora diciamo partendo dall'inizio, proprio dal primissimo momento voi mi conoscete, sapete che giornalmente sono un burlone, ti ho fatto uno scherzone per la cronaca non voluto perché mi sono dimenticato per davvero di chiedertelo e quindi vabbè ho detto proviamo comunque allora io sono un burlone, l'avete visto scherzo spesso e volentieri anche in ambiti assurdi, però Marco mi si è avvicinato e ha detto "ah ma beh ma perché voglio fare qualcosa di bello" e ho detto "lo guarda" e ho pensato "fa sul serio, non fa sul serio, la butta lì tanto per, però poi non è sul serio" però a un certo punto mi sono reso conto che si scherzava ma non completamente, quindi era davvero interessato e allora il punto era, questo magari ne possiamo parlare in seguito, ma parte dell'attività del DX Team o DevRel, come lo vuoi chiamare tu, perché poi manco noi sappiamo come ci chiamiamo di preciso, siamo di solito DX ma facciamo DevRel per tutto il resto del pianeta, quindi passiamoci il nome. Il punto è stato, come DX noi, come NearForm, il DX Team di NearForm non è solo pensato per l'esterno, diciamo, noi facciamo DX verso l'esterno. Il team è pensato anche per fare mentoring, appunto, e attività di coaching coaching interne. Quindi se viene una persona da me e dice voglio fare, inizierò a fare sul Node io ti piglio, a un certo punto ti prendo sul serio. A quel punto ho applicato l'unico metodo che conoscevo e anche un metodo per cui ho letteralmente mandato a quel paese in maniera buonaria il mio mentore sul Node durante un collab summit, perché vi racconto questo aneddoto. Durante il collab summit che ha proceduto il NodeConf, quindi vi parlo di ottobre noi con il collaboratore discutevamo su come si porta nuova gente sul Nod, come si fa, come possiamo fare in modo che la gente venga sul Nod, inizi a contribuire e vada avanti e il mio mentore che è il buon Matteo Collina che tutti ben conoscete se n'è uscito con "beh li sommergiamo di isciu e vediamo se si riemergono" letteralmente, questo è letteralmente ciò che ha detto davanti a tutti quanti al che io ti avrei risposto di mi hai fatto morire per mesi, vai a cagare, buonariamente proprio. Però, quando poi mi è troccato a me, mi sono reso conto che effettivamente l'unico metodo è quello, ovvero, è chiaro che non ti lascio in una issue senza guida, però te ne do tante, con difficoltà spero crescenti, sottolineo spero perché a volte quella che sembra il fix di una riga si rileva in un incubo di due mesi e viceversa, e viceversa. Quindi uno ci prova da quello che la Iscio descrive, dice "guarda, questa mi pare facile, poi magari è un assurdo incubo, però ci proviamo". Quindi a difficoltà crescenti, seguendo in questo caso Marco mano a mano e diciamo guidandolo nel prendere familiarità con una porzione del codice di Nod, fino a che poi non diventi autonomo e poi inizi a farlo da solo. Purtroppo non c'è altro da fare, sembra crudele, sembra il classico paragone degli spartani che buttavano la gente dalla rupe o i leoni dalla rupe e robe del genere. Ma in questo caso purtroppo non ho trovato un metodo migliore, però a quanto pare ha funzionato quindi o mi è andata di fortuna o ci ho colto una delle due, non lo so. Ma quindi non esiste un learning path per l'esplorazione di una codebase vasta e complicata come può essere quella di Node? Secondo me il problema non è la vastità ma è l'età, perché è quello il problema. La codebase basta, puoi provare pure a esplorarla, ma se noi pensiamo che Node, la prima release uscita alla bellezza di, stiamo nel 23, di 14 anni fa, quando si scriveva un javascript diverso, con dei pattern diversi e robe varie, e ci sono pezzi stratificati di quella codebase, perché magari ci sono dei moduli in recenti, quindi il codice abbastanza recente, la butto lì, l'ultimo inserito il test runner, è codice recente, più o meno ci si riesce a mettere mano. Ma nel mio caso specifico ho scelto all'epoca di occuparmi dello stack HTTP di Node, quindi HTTP client o HTTP server, che esistono dalla versione 0 di Node. Quindi lì c'è stratificato 14 anni di bug, feature, refactoring, refactoring soprattutto parziali, sfortunatamente, che poi si vanno magari a combinare con, simultaneamente, la stessa situazione nel modulo stream e la stessa situazione nel modulo net, perché poi si basano su quelli, e quindi il problema non è capire come è fatto il codice, bene o male lo riesce a seguire, a volte è capire perché fa così, è una cosa antilogica, ma poi capisci che aveva senso quando venne scritto, ma adesso è stato tolto, ma non è stato aggiornato tutto, perché ovviamente è enorme, Marco potrà confermare, ci sono delle cose da comprendere, ci vuole un giorno solo a capire che cosa fa una riga di codice certe volte e non è quante righe sono e quali righe sono sfortunatamente. Voglio passare a Marco. C'era una volta Marco che fa il pull della codebase di Node e inizia a metterci mano. Sinceramente, dal momento in cui tu hai aperto il primo file, qual è stata la tua paura se ne hai avuto una? Il primo impatto con Node è spaventoso perché diciamo anche solo per buildare il progetto e per lanciare i test bisogna seguire una guida piuttosto dettagliata quindi scaricare Xcode, fare il setup di Ccache, Ninja, ci sono tutta una parte di tooling che va fatto il setup e poi la prima build impiegò qualcosa come 20 minuti quindi ho detto ma cosa sto facendo javascript cosa sto facendo e infatti poi diciamo lavorare sul codice è stato come imparare un linguaggio nuovo perché il javascript con cui è scritto node è un po particolare sono dei dei pattern gruppo non ero familiari, dei pezzi di codice un po' arcani, che non avevo mai visto nella mia esperienza. Quindi mi sono ritrovato come da zero, come una persona che deve imparare tutto e su quella codebase ero un po' spesato. Però grazie alla prima issue, che era un'issue banale, però da lì grazie all'aiuto di Paolo, guardando, spiegandomi cosa faceva questo pezzo di codice, cercare di capire cosa stesse succedendo, da lì piano piano ho iniziato a prendere familiarità con il codice attorno a quello che poi su cui dovevo lavorare per risolvere la issue, quindi prima capire cosa faceva quella funzione, capire cosa faceva quel file e anche adesso dopo un bel po' di contribuzioni penso di aver visto forse il 5% della codebase e ci sono tantissime parti di cui non conosco nulla e non ho mai visto ancora per quanto è vasto e complesso il progetto, quindi diciamo la mia paura è stata di non essere in grado di non essere capace poi di metterci le mani, perché una volta scaricato magari compila pure. Poi il problema è farla e risolverla la issue. Non è stato facilissimo. Vedo ancora la fatica e il dolore nei tuoi occhi mentre lo racconti e poi lo passi con la testa. No un po' sai mi hai ricordato non tanto tempo fa, qualche settimana fa, quando mi son compilato NodeCore che era il primo... scusami mi son compilato Bitcoin Core anche quello una codebase dove c'è il cppum, è una compilazione che dura più di un'oretta Perlomeno la mia macchina ci ha messo più di un'ora nel portatile E là si attiva una cosa, si attiva la solitamente faccio apre una parentesi solitamente quando approcciamo una codebase in un modo o nell'altro in prima, seconda issue riusciamo a conoscere e esplorare una buona parte del progetto 60 70 per cento prima, seconda, terza issue e quindi siamo confident. Nel momento in cui si approccia a questa enorme codebase si deve superare il limite psicologico del "non posso sapere tutto" quindi in qualche modo devo fare i conti con quello che non posso sapere, che mi circonda e che magari in parte devo intuire. E questa è questa cosa spaventa e questa cosa spesso triggere. Io porto anche un po' della mia esperienza personale spesso triggera il far capo, il contattare il mentore. Adesso con quanto ogni quanto lasso di tempo a contattare il mentore quello varia dalla paura che si genera, quindi dal loop di paura, di tensione interna che si genera e dalla disponibilità del mentore. C'è da dire che si rischia di finire in situazioni dove si pinga il mentore ogni quarto d'ora. E qua voglio passare dal mentore invece, come si fa a Paolo quindi? Come si fa a controllare il pushback da parte del mentino? Il fatto di "pa' non ci ho capito un cazzo, aiutami, pa' che cos'è questa cosa?" e come fa il mentor a dire "no, spendici un'altra ora"? Qual è la linea guida per dire "no, ci devi investire ancora più effort tu prima di venirti a guidare"? Allora faccio una digressione giusto su quello che hai detto prima per fare un plauso a chi ha organizzato Node, perché è una cosa che tu parlavi sul discorso del 60-70% della codebase, eccetera. Quando io ti ho detto che mi occupavo dello stack HTTP di node, non era un'informazione completamente casuale, nel senso, quando tu inizi a contribuire sul node, scegli un ambito di cui occuparti. Nessuno si aspetta che tu conosca tutti i moduli. Io conosco solo HTTP, NAT e stream. Non ho idea di come sia fatto per esempio crypto o Zlib, roba del genere. Quindi questo ti aiuta, perché tu sai che arrivano liscio su Zlib, a parte che GitHub nemmeno ti notifica, perché sono fatto in un modo particolare la notifica. Se la IC non ha a che fare con lo stack di cui ti occupi, te ne puoi dimenticare. E ti aiuta perché ti aiuta l'ansia di dire "non devo imparare tutto, non imparo la parte di cui mi occupo". Poi se voglio aggiungere un altro pezzo, scelta mia, posso iscrivermi a un nuovo team interno e andiamo avanti. Quindi questo diciamo aiuta la gestione del... di gestire, diciamo, il nuovo ignoto praticamente, da un lato. Per tornare alla tua domanda comunque, ti posso dire che... Allora, precisando che Marco è stato il mio primo mentee, quindi diciamo l'ho usato un po' come cavia, in realtà ho usato un approccio molto casuale e molto involontario. Nel senso Marco mi scriveva sempre, magari su Slack, dicendo "guarda Pa, sto bloccato su 'sta issue". Dico "va bene Marco, non ci stanno problemi, fammi finire di fa' 'sta cosa", che sto freddando perché io odio, diciamo, interrompere il task, finiti fa sta cosa, ci sentiamo tra una mezz'oretta, tra un'ora e tre, che poi diventano sempre due ore purtroppo, confermarlo perché la mia stima dei tempi fa decisamente cagare, ma lasciamo perdere. Però il punto è, ci vediamo tra un'ora che diventano due, tu nel frattempo continui a darci un'occhiata, vedi che ci cavi un ragno dal buco e a volte, effettuando un quarto d'ora dopo, ok, va fatto. Completamente a caso, non era mia intenzione fare il pushback che dici tu, però se qualche mentre ora l'ascolto, 'sto trucchetto può funzionare, perché non fai percepire magari al menti che lo stai facendo il push back per dire "meh, mettici un po' più il culo sulla sedia" per mettere, diciamo, per citare magari i nostri genitori ai tempi dello studio, da un lato. Però dall'altro questa tecnica io la userei anche continuamente per verificare, assaggiare la grinta della persona, perché poi anche quello, cioè tu puoi avere la volontà la risa un node. Perfetto. La buona fede nessuno la discute, però se fa a un certo punto non riesce a dimostrare il grinta nel dire ok, se tu non mi puoi rispondere subito, ci continui a sbattere la testa, magari non arrivo a niente, però tra due ore ti potrò sicuramente dare qualche informazione in più e dimostrare che almeno c'hai messo la grinta o per dirla la napoletana la cazzimma sopra per portarti avanti la la issue. È un buon modo per valutare anche l'aspetto psicologico piuttosto che quello tecnico del mentino. Questa è una cosa interessante perché in realtà dimostra quanto skin in the game c'è da parte del mentino. Adesso faccio una domanda che però presuppone una risposta sincerissima da parte di Marco. Nel momento in cui si riceve un push back e tu ti trovi nella merda fino al naso perché non ci stai capendo una cippa di quello che ti circonda. Capita, a me capita costantemente, capita a tutti, anche ai senior, anche agli staff, anche ai ninja. In quel momento è noto che comunque si attiva un carico psicologico nel dire "non ce la faccio, vaffanculo, lascio tutto, non sono all'altezza" quindi si triggera la sindrome dell'impostore. Come hai gestito queste paure, anche la sindrome dell'impostore poi alla fine? Certo, ma io in In questa situazione che hai descritto mi sono ritrovato molte volte, soprattutto ai primi task, ma tuttora ci sono delle volte che dico "non ho idea di questa cosa, come risolverla". Diciamo, lavorare su Nord mi ha insegnato molto da questo punto di vista perché ho capito che le risposte non arrivano subito, bisogna dargli del tempo. Per esempio, guardando quelle che sono le issues o GitHub, nessuno si aspetta che tu risolvi una issue in un giorno o due giorni, non c'è nessuno lì che ti dice "Ehi, dai, risolvila". C'è bisogno del suo tempo, della sua ricerca e comunque anche della crescita che c'è dietro la risoluzione di una issue, di cercare di capire il contesto. Per esempio, ci sono volte in cui ho staccato e ho fatto altro. Altre volte in cui sono andato su GitHub e ho iniziato a vedere magari nelle pull request passate su quel pezzo di codice quali fossero stati i commenti a riguardo del background che c'era dietro una issue, di chi ci aveva lavorato, di quanto tempo fa, o magari chiedevo ad altre persone che avevano lavorato più contesto riguardo a quel pezzo di codice. Quindi, diciamo che la cosa più importante secondo me è non andare nel panico, perché alla fine nell'open source su queste cose non ti corre dietro nessuno. Bisogna essere pazienti, soprattutto con se stessi, secondo me, non agitarsi troppo. Poi, mentre aspettavo che Paolo si liberasse, devo dire che io non mi ho mai messo pressione, non mi sono mai sentito sotto pressione, anzi per me, dirmi "guarda ci sentiamo tra un po' perché sto impegnato" oppure "ci sentiamo domani mattina" io l'ho vista come una cosa totalmente naturale, perché ognuno lavora su progetti diversi e ci sta che la comunicazione sia asincrona. Quindi mi ha aiutato molto e per me è stata naturale poi la progressione verso l'essere un po' più indipendente. Anch'io ho iniziato sulla parte HTTP, in modo che comunque potevamo essere allineati, io e Paolo, conoscendo lo stesso modulo. E Poi pian piano mi sono spostato anche su altre parti, quella degli stream, adesso sto lavorando sulla parte di un po' di tooling, sulla parte di sicurezza. Quindi poi credo che vada un po' a gusto personale la parte del progetto su cui ci piace lavorare, però come ha detto Paolo bisogna iniziare da una cosa, che poi diventa troppo dispersiva. Hai detto una cosa guarassanta, ti offrirei un pasticcino per quello che hai detto, perché credimi, quello di prendersi il proprio tempo. Io questa cosa l'ho imparata in Irthorne, l'azienda dove lavoro, e mi è costato parecchio sforzo all'inizio, nel senso che ero abituato a gestire codebase che avevo fatto sempre partire da zero io. Il margine di tempo che si ha dal verificarsi un problema all'immaginare la soluzione è molto limitato, perché conosci ogni angolo della code base che hai fatto. Quando approcci su progetti a più mani, di complessità più grande, devi in qualche modo, lo devi a te stesso, devi darti tempo. E quando tu leggi un issue e non hai idea di come risolverla dopo i primi 5 minuti, è normale che le prime volte ti sale l'incazzo, ti viene nervoso. perché dici "no, no, ma là sono veramente tonto". Non funziona così, perché tu devi creare la struttura di contesto che è quello che diceva Marco poco fa, ti devi creare il contesto, la base, e ti devi lasciare il tempo di raggiungere la soluzione, perché c'è un viaggio e durante questo viaggio che passa dal capisco il problema perché anche il comprendere il problema ha bisogno di tempo a ho idea di come posso risolverlo, lungo questo viaggio quello che succede è che tu scopri la codebase, ne scopri una parte ancora più grande e soprattutto tu diventi confident anche quei tuoi tempi, tempi che voi anche per il mondo che viviamo, per i social che ci hanno abituato a una comunicazione bom bom bom bom bom bom o alle informazioni a spizzi che bottoni e bocconi non ci diamo più. Dobbiamo rimpossessarci del nostro tempo anche quando lavoriamo. Vi dico un'altra cosa, io avevo l'idea di chiudere sempre l'issue in massimo una giornata lavorativa. La prima volta che ho trovato un'issue su autocannon, mi sa che me l'hai fatta tu la review Paolo o tu o Matteo, e ci sono rimasti tre giorni. E vabbè che sono tre giorni, ma Marco ha un issue che lo sa però! cioè sul node il tempo medio delle mie issue sta un mese scusa, delle PR, non delle issue, delle PR un mese ci metto io a mergearla Raffael anche 7 mesi c'è stata il permission model il permission model è di 7 mesi? ma è follia tra l'altro si considera che sulle issue di node il carico cognitivo è doppio perché tu non vuoi guardare solo la code base node, guardi anche la code base di chi ti ha riportato il bug Marco sa benissimo perché abbiamo lavorato su due issue simili ma diverse ha già capito, si è messo le mani in faccia e riguarda, non voglio dare la colpa perché ci sono capitati loro, però può essere chiunque l'SDK di AWS ci hanno riportato due issue diverse una faceva crashare le assertions delle HTTP server e l'altra faceva uscire node senza errori perché svuotava l'event loop quindi tu hai dovuto capire prima cosa facesse Node e poi cosa cavolo facesse le SDK di AWS che tu non vedi mai e ti dimenticherai due minuti dopo. Quanto ci abbiamo messo Marco a fare la diagnosi prima della soluzione? Sì quella diagnosi diciamo è stata terribile penso una delle issue che poi poi il problema non era nemmeno che c'era un bug, ma è dimostrare che non fosse un bug di node perché il processo usciva in maniera pulita, quindi il problema era appunto che usciva questo processo e non si capiva il perché e quindi grazie a questa issue ho imparato molto bene andare a debuggare node, ho dovuto ripercorrere tutto quello che è lo stack della richiesta e anche però ho dovuto conoscere la codebase della SDK di AWS che neanche quella non è una codebase facile e poi ho scoperto che alla fine non era un bug di noto, quindi tutto lo sforzo per poi non c'è niente da fixare, è solo lato AWS tanto lavoro per poi... due mesi della nostra ed è buttati proprio perché è da buttati? Gli utenti adesso lo sanno, la issue su AWS è ancora aperta, non l'hanno fixata ho anche aperto una pull request che state ignorando se lavorate per EWS andate a vedere la pull request c'è qualcuno che ci sente che lavora per EWS la guardavo perché i processi che terminano in Xtethic Code 0 non è una bella cosa che usciva in Xthetic Code 0, non ho mai visto svuotare l'event loop di node non mi mancava sta cosa in tanti anni però per dirti, quindi di darti il tempo tempo io all'inizio ero come te Mauro, gli dice cavolo ci sto mettendo un sacco di tempo, ci sto mettendo un sacco di tempo, poi vado a vedere, Raffael ci ha messo sette mesi. Per farti un altro esempio, James Nell che ha implementato il protocollo QUIC per Nod, quindi QUIC la base di HTTP3 eccetera, ha aperto la pull request tre anni fa, è ancora aperta, l'ha riaperta la seconda volta perché era troppo grande e gli hanno chiesto di spezzarla e l'ha riaperta una terza volta, e ancora non è emergiata. Perché nessuno riesce a fa la review di quella, il pull request perché è enorme. Anche quella è una cosa è una cosa interessante ci arriviamo dopo però sul processo di review e sulla comunicazione che sta nel processo di review. Nel momento in cui il tempo per portare a compimento una pull request è così lungo E questo lo chiedo a Paolo, ancora prima di Marco, perché comunque c'è una risposta da mentor e una risposta più personale. Quando il tempo è così lungo, i sette mesi di Raffael per fare il sistema di diritti, come si chiamano le autorizzazioni? Permission model. Permission model di Nod, come fai ad avere una motivazione tale per cui riesci a passarli questi sette mesi senza dire "oh vaffanculo io la PR la chiudo, la PR la chiudo e ciccia". Credo che la risposta sia personale, non c'è una risposta univoca. Per esempio per me apro la PR, a un certo punto vedo che ancora non viene emergiata e mi girano mi girano profondamente, quel senso di incompiuto mi stupendo, mi turba mia moglie mi diciamo mi prende in giro che c'ho i disturbi ossessivo compulsivi che sono ingegnere quindi sono coi paraocchi quel che ti pare probabilmente è così la mia personalità è stata rovinata dai miei studi probabilmente sicuramente però io ogni tanto vado su GitHub pul request e vedo una piarra aperta da un mese dica cavolo cavolo cavolo sta piazza chiude cioè non non riesco a guardarla lì in completo potrei anche dire come dici tu sai che c'è mi sono stufato me la auto chiudo che però poi la subendo il fatto è se la chiudo comunque incompleta e allora lì mi triggera il il range mode praticamente però la risposta che suppongo sia personale perché ognuno la vede a modo proprio rafael alla fine ci ha messo sette mesi perché comunque l'ha dovuto rivedere più volte per dirti non è inusuale che se non tu la una piara la possa riscrivere diverse volte all'interno della stessa piada fai force push perché la tua prima soluzione o era in compo non proprio incorretta ma non diciamo non proprio corretta corretta totalmente oppure aveva degli obbrobriosi affetti collaterali che non potevamo anche immaginare. Per dirti l'ultima io ho solo una PR pendente al momento che non riesco a chiudere perché in locale e sul mio server Linux in remoto passano i test vado sulla siedino dei test non passano e non ho modo di riprodurre il problema non riesco a riprodurlo ma non posso chiudere quella PR. La PR è è completamente fatta, testata in locale, che non crasha mai, crasha in remoto. E quella rimane lì. La classica spina nel fianco che ti dice "ma, santa pace". Poi, per esempio, nel mio caso specifico, questa PR è una SemVer Major, e Rafael mi ha detto "guarda, pa', io devo chiudere la code base di Not20, la devo chiudere il 1 Aprile, quindi ho quattro giorni per farla passare". se no se ne parla l'anno prossimo per essere inclusi in una linea stabile e questo Raffael non l'ha detto con cattiva intenzione me l'ha semplicemente comunicato, cioè guarda cerca di farlo entro il primo aprile che lo includiamo in Veneti pensa quando sto rilassato verso Stappi Aramo cioè è quello, almeno per me è questo a livello psicologico però, e il problema è chiaro, a livello psicologico come lo gestisci o non lo gestisci? Allora, all'inizio mi da la motivazione, poi se non riesco a te, a volte la motivazione, magari l'ho fatta, lasciata lì un po' pendente, anche perché poi avevo altre cose da fare, perché sia per me che per Marco fare il Node Contributor non è nella parte hobby del tempo, ma è nella parte lavorativa, quindi è chiaro che se io magari una volta posso prendermi il tempo sul Node, poi devo andare in conferenza per dirne una. per me è una cosa che mi piace molto. Allora la devo lasciar perdere. Poi a certo punto dico mi ricordo guarda c'è Stappiarra che la devi la devi la dobbiamo omergiare il fatto che magari sto stretto di tempi mi dà la motivazione per eh approcciarle mi dà diciamo la grinta agonistica se mi passate il termine che se poi non riesco a risolvere diventa frustrazione agonistica e mi allontano da altre tre settimane da Stappiarra per il nervoso e passo ad altro quindi però non è un rinforzo positivo e negativo continuo che boh è un senso di frustrazione assoluto onestamente poi a volte lo prendi in maniera positiva a volte in maniera negativa ma l'allungo è quello ti ti ti lascia poi ci sono anche sistemi impliciti di node che ti fanno morire tipo la tua piatra funziona è tutta a posto ma hai dimenticato di fare il su una riga riga di codice la SI non passa fai un un altro approval e altre due giorni per poterla mergeare perché c'è il wait time dopo l'ultimo approval e a quel punto vuoi buttare all'aria tutti i computer che c'hai a tiro. True story Marco Annuito perché gli è successo delle più volte e là vuoi uccidere qualcuno non ci stanno santi. Quindi ci sono vari problemi. Problemi non in notte, attenzione, in feedback psicologici. Marco invece tu come hai gestito questa cosa della motivazione quando poi i tempi si dilattano? Dunque, io non ho avuto PR con tempi lunghissimi, diciamo che tutte le PR che ho aperto sono state emergiate nel giro di massimo un mesetto. Qualcuno potrebbe dire che sono tempi abbastanza lunghi, però per un progetto come Node in cui c'è bisogno che diverse persone facciano una review, quindi come ha detto Paolo, ti ritrovi più volte a dover riscrivere tutto. Anche perché è importante dire che su Node ci sono delle persone che conoscono molto bene degli ambiti e hanno il contesto necessario per capire quello che sta succedendo nella tua pull request, quindi se effetti un cambiamento che ti tieni in sciocco, magari quella linea di codice è stata messa lì 4 anni fa per un motivo che non conoscerei mai e quindi durante la fase di review ti viene detto "no, la tua pull request non va bene, riscritta dal capo quella riga di codice non la puoi toccare e da lì riparte tutto il processo a me è capitato qualcosa del genere che magari fai il tuo fix funziona perfettamente apri la pull request e quando nella fase di review ti dicono "riscrivi tutto" va bene ma è anche questo un po' il bello di Node e secondo me ecco ci vuole tanta umiltà e poi anche capire che si è lì anche per imparare, perché alla fine si impara sempre di più, si scoprono cose nuove. Io non l'ho mai vissuta male, oppure non l'ho mai vissuta come una critica personale, l'ho sempre trovato molto, molto costruttivo e questo credo che mi abbia permesso anche di trovare la motivazione per andare avanti, perché sono l'ultimo arrivato sul progetto, quindi ho tutto da imparare. Aggiungo alcuna cosa a quello che ha detto Marco. Il processo di pull request review, su cui torneremo dopo, come hai chiesto tu Mauro. Quando Marco parla del fatto che ti fanno la review e dicono "guarda, sta riga non la devi toccare" o "questo non va bene", roba del genere. Capita a me spesso quando tocco il codice C++, se non ho almeno una review da, per esempio, che conosce bene il layer c++ non mi sento a mio agio ammiragiarla perché so che se lo guarda lei vado tranquillo. Allora il punto è è sempre fatto però col rispetto col massimo rispetto e mai con la cattiveria o la spocchia che uno potrebbe immaginare cioè ti arriva uno come Matteo, come Anna, come James con la tranquillità più assoluta dicono guarda no guarda no guarda no in maniera molto brutale però pulita onesta, massimo rispetto e perché appunto l'unico scopo è uno la qualità del progetto e due la costruttività e la sostenibilità come terza cosa sia assolutamente. Perché se Marco va via, Polo va via, Node crolla sotto il suo peso, James va via. Abbiamo un problema nei core team che non avete Avete parlato di righe che non vanno toccate e in tante codebase questa cosa è presente, spesso sono dei pezzi di codice che io amo chiamare, che nascondono una tribal knowledge, quindi un qualcosa rilasciato di padre in figlio da cold maintainer a young contributor tipo le leggende sulla casa degli spiriti qualcosa del genere. Quando però ci si approccia a una codebase base... cavolo la tribal knowledge è obscurity, è qualcosa che non si conosce, che difficilmente si conosce, io in un talk la chiamai gli unknown, ciò che non sai di non sapere, ed è difficilissimo da spottare questa cosa. Dal vostro punto di vista esiste un modo per sistematizzare questa conoscenza? Per fare in modo che una volta che è passato Marco, che quell'informazione è passata, sia in qualche modo lasciata ai posteri in, non lo so, in qualche modo? per me la risposta è dipende. A parte che tu hai curiosamente citato il fatto di tramandare la conoscenza di padre in figlio, faccio presente che su Node Core adesso non è ancora un collaboratore ma prima o poi ci arriverà, James Nell collabora col figlio che adesso fa esistere nei suoi bug. Siamo arrivati al punto che ci sono padre e figlio letteralmente sul progetto, che sembra una battuta ma è successo, ho conosciuto il figlio ragazzo fantastico a Kilkenny al non confo questo lo scorso ottobre ma comunque ma ora il problema è che dipende perché quella che tu chiami tribal knowledge ci possono essere due possibilità è stata generata volutamente o è stata generata per caso ora se qualcuno tre anni fa ha scritto una riga oscura che ne so un bitwise operator per dirti una cosa più assurda che mi viene in mente e non c'ha scritto un commento sopra merita di essere che qualcuno vada a bussare alla casa e gli e gli tiri un bel cazzotto in faccia, perché giustamente è cattiveria quella. Ci sono ovviamente case del genere, e questi sono i casi in cui si dovrebbe evitare di dire sì, ma in fase di pull request, hai scritto 'starica' che non vuol dire niente, mettici un commento, cosa che spesso succede, qualche volta ci chiedono nel codice, ragazzi, due commenti nel codice, perché sennò tra due anni voi stessi non vi ricordate perché l'avete messo. Che succede spesso. Questa è una. L'altra, purtroppo, nella mia esperienza, è quello che mi sono trovato a vedere sul Node, è l'oscurity involontaria c'è una riga di codice che potrebbe essere l'ultima superstitie di dieci precedenti righe di codice che una volta messe tutte insieme avevano senso c'è rimasta solo lei per qualche motivo e quella è rimasta di nuovo si troverebbe che in fase di pull request quando tu inizi a eliminare quelle righe di codice "sì ma quando ne eliminate una?" metteteci un commento che ne so, questa operazione non è più necessaria a questa sottosi per cose del genere, no? si può intervenire solo in fase di pull request, perché l'unico controllo è la... scusami, intendo fase di pull request review, ovviamente, perché se nessuno controlla il codice che scrivi, tu non ci metti niente. Ti faccio un esempio. Io ho citato che sono nello stack HTTP di Node. Una cosa che ho tuttora omesso di dire è che sono anche uno dei principali, se non il principale attualmente, maintainer di LLHTTP, che è il parser HTTP di Node. che è una libreria che, ascoltatori, mi sgancio una bomba, è un codice che transpila da TypeScript a C, senza passare per JavaScript e roba di mezzo. Da TypeScript viene generata una libreria C statica. Eh, ragazzi, il vostro contesto Mauro sta facendo faccia che non avete idea, che dice "che è sta roba?" Io infatti quando l'ho vista ho detto "ma come è possibile?" perché LLHTTP si basa su un parser chiamato LLParse che fa questa cosa qui, che può scrivere qualunque tipo di parsing di linguaggi LL, praticamente. Ora, il problema è, questo software è stato scritto da Fedor Indutni quasi in totale isolamento, ci ha fatto anche un tolco sopra che spiegava un po' come era fatto, più o meno, non c'è uno straccio di documentazione, una, che sia una. io che ci ho dovuto mettere in mano LLCTP mi pare di un Marco non so se tu ci hai messo mai in mano una misa di nota, sei scampato? No. Full bacchione. Ehh... Aspetta, aspetta, aspetta, t'aggiusto io, mo' appena mi ricapita. No, scherzi a parte, però... Però chi mi fa le review, per esempio, chi mi fa le review su LLCTP mi fa le review e dico "sì, ma io ipotizzo che quello che tu hai fatto è corretto perché io non so cosa ho fatto". Chi mi fa la review non ha idea di che cavolo io abbia fatto e perché l'abbia fatto. ah, i test sono scritti in markdown traspilato in c per intenderci, quindi è una cosa un po' assurda non avete idea il discorso è che quello è un intero pezzo di software che è oscurità pura non c'è uno straccio di documentazione da nessuna parte non c'era neanche la procedura di release, in realtà l'ho dovuta creare io da zero la procedura di release per fare il cutout di una nuova patch version o quello che è Quella è oscurità voluta, che però all'epoca il punto qual era? Era involontaria, perché Fedor era presente nel team quindi dici "guarda Fedor, ho questo problema con le LCTP", vabbè ci penso io, quindi il classico single point of failure Nel tempo lui è sparito, perché io non lo vedo online da diverso tempo, diciamo come attività pubblica ci avrà i suoi problemi, ci avrà il suo lavoro, nessuno gli può dire nulla per carità quel software che era conosciuto è di punto in bianco diventato un buco nero che su cui si può mettere mano in maniera molto limitata e non c'è niente che si possa fare perché non è una situazione prevedibile perché io non prevedo di sparire da la mattina alla sera da domani no? Quindi che puoi fare? Essere più proattivo e dire se mi succede qualcosa da buon tesoro sudi lì si fa fare corna da tutte le parti mentre scrivi la documentazione allora come fai? È un po' complessa come situazione. Questo lo capisco, nel contempo però posso dire che qua tocchiamo un punto borderline, perché io ho sempre detto che il codice è uno strumento di comunicazione tra umani e non tra uomo e macchina, perché se io voglio comunicare con la macchina io scrivo in assembly. Ma se sto scrivendo un codice in qualche modo devo comunicare con gli esseri umani. Se utilizzo un linguaggio ignoto, se scrivi in aramaico, non posso pretendere che gli umani moderni spreddano il mio verbo in modo semplice o comunque si prendano in carico le mie parole e questa cosa funziona nei software a un certo livello quando più scendi sotto e più ho notato che questo trattare il codice come mezzo di comunicazione un po si perde vuoi perché devi privilegiare le performance vuoi perché talvolta devi fare una patch a qualcosa di di particolare, non lo so, però una cosa che noto è che veramente quel senso di strumento di comunicazione un po' si perde e a quel punto secondo me è anche una questione di responsabilità. C'è da dire che magari chi ha scritto quel pezzo di codice l'ha fatto per farlo nel minor tempo possibile con degli strumenti che gli permettevano di farlo nel il minore tempo possibile però là c'è sempre il trade off, quindi tu fai qualcosa velocemente e però poi rimane là e mancano le risorse per portare avanti poi quel pezzo di codice. Il problema è quello, la cosa che ho cominciato a dire è che storicamente io sono entrato nel team di Nod un anno e mezzo fa e l'HTTP è stato creato tre anni fa se non ricordo male perché è stato creato perché il vecchio parser di Nod chiamato con molta fantasia HTTP_PARSER era lento, era mostruosamente lento. Allora si sono posti il problema, "Ah, ragazzi, dobbiamo creare un parser che sia veloce". Quello che ho detto, TypeScript AC, alla fine ad alto livello, cos'è? Un gigantesco switch statement, immaginate uno switch gigantesco con qualcosa come centinaia di migliaia di case, così funziona, che è il modo più veloce, mi è stato detto, anche in altri ambiti, utilizzato lo stesso trucchetto per fare del software iper ottimizzato come per queste prestazioni. La leggibilità va a donnine però. E il punto, tu hai ragione nel dire "sì ma dovremmo comunicare" è vero, però dovremmo anche essere performanti, dovremmo anche essere sicuri, dovremmo anche essere, passandomi il termine, sexy per gli utenti. Quante cose dobbiamo vedere simultaneamente? Purtroppo la documentazione, come la testabilità spesso, sono quelle che prima se ne vanno all'aria. La famosa cosa del triangolo "hai tre cose, scegli ne due" sta a sicuro che la documentazione è quella che se ne viene ignorata, abbiatamente, e di cui ti penti due anni dopo, però, ovviamente. Però ti ha fatto sopravvivere nel breve termine. Voglio ritornare a Marco. Hai parlato di codice arcano, un po' fuori dai canoni del javascript che avevi usato fino ad allora. Cosa intendi per codice arcano? Quali erano i costrutti? Siccome dagli ascoltatori ce ne sono un gozziliardo che secondo me su 1500 1600 ascoltatori, 1200 lavorano i javascript e quindi ti chiedo cosa è che hai trovato così strano, così arcano, così neolitico. Dunque, allora in particolare, non è che c'è un operatore in particolare, però si può vedere un po' come un geologo che guarda un sedimento, si vede proprio la stratificazione del codice negli anni, cioè vedi dei pezzi di codice, quelli più antichi, vedi come si usava a fare una una volta in javascript lavorare con i prototype degli oggetti non c'era il chaining condizionale quindi c'erano questi if and and and lunghissimi diverse cose che magari non ti aspetti perché c'è una riga che è molto moderna e quella successiva magari risulta strana. È un po' un mix, un mix di persone, un mix di tempi diversi in cui anche si usavano tecnologie diverse, c'erano stili differenti quindi questo aumenta un po' la complessità. Come suggerisce Paolo i primordials che prima di Nodd non avevamo mai visto, prima di lavorare su Nodd non avevamo mai visto e su Nodd si usa. Che roba è? Io non l'ho mai visto dico la verità. Non lo vuoi sapere. - Vai Marco, provaci tu, non so neanche come spiegarlo di preciso. - Allora, sono delle...per esempio io ho messo le mani per divertimento su un array join, che la funzione join di un array in Node è un primordial che dovrebbe essere una funzione che corrisponde alla sua implementazione javascript pura cioè quella che viene eseguita poi da V8 Paolo, magari, correggimi perché è un po' un concetto arcano per mantenersi sull'esempio di array.join se tu avessi un array di string in javascript avresti array(1,2,3).join qualunque carattere in mezzo questa sarebbe la chiamata tipica in javascript ora il punto è che in Node a un certo punto si sono posti il problema di dire all'interno di Node fare una cosa del genere è pericoloso perché se qualcuno modifica la firma di join, come puoi fare in JavaScript, il monkey patching classico, modifichi il metodo join, Dio solo sa quello che possono fare. Perché noi quando andiamo a eseguirla all'interno di Node Core, utilizzeremo quella funzione e vai a vedere che succede. Quindi è un problema di sicurezza gigantesco. Si chiama prototype pollution. Che JavaScript lo permette. Allora, qual è la soluzione che hanno trovato? che funziona perfettamente, è un palo nel sedere quando scrivi l'APR, perché è un incubo. Se te lo dimentichi ti rompe le scatole l'Inter e tutto il discorso della CI, oppure ti devi ricordare di poi metterli in ordine, insomma, è un po' contorta la cosa. Però in pratica il punto qual è? Che io invece di fare array.join faccio const array.join, che è una funzione senza il punto, array.join, mancava il case, required da primordials e poi faccio array join, il primo argomento è l'array e il secondo è il separatore non so se ho reso l'idea è come se facessi in pratica la call, come quando facciamo la call, fai function.call il target del messaggio e gli argomenti e lo fai per ogni singola funzione, array join, array push che ne so, mat.random, tutte, tutte sono utilizzate così, immagina quanto è bello usarle Guarda tranquillo non l'ultimo progetto ma qualche progetto fa io ho visto una roba del genere fatto con l'Odash quindi non dai primordial ma dall'Odash La situazione era praticamente la stessa Performante come un appepiaggio del 74 però quello, capisci che quando inizi a vedere quello, non è il JavaScript che tu scriverai mai, a me è come se finissi in progetti brutti, ma in generale è il JavaScript che non scriveresti mai. Ma poi appunto, è un JavaScript anti-pattern che scrivono le più grosse persone talentose in JavaScript del pianeta, c'è il motivo, come ti dicevo è perfettamente sensata la soluzione, molto intelligente, è un po' anti-pattern. Ma queste cose fondamentalmente sono documentate? Non credo. Sì, ma le leggerai dopo che le trovate? Cioè la documentazione la troverai molto dopo che avrai cercato di lavorarci e di capire, perché comunque c'è tantissima documentazione, ci sono tantissime strade anche di documentazione, quindi anche il primo impatto copremorta non si può fare. Ma perché? Però anche questi sono gentili su Node, cioè su Node siamo gentili perché per esempio se io dimentico di usare un primordials non mi sbattono un rtfm a caso, read the fucking manual a caso, ma dicono "guarda dove ti ho dato" usare i primordials poi magari dico "scusa ma fa capire perché" e allora a quel punto mi sbattono in link alla guida "guarda c'è scritto" e Giuseppe mi dice "Marco ma tu lo sai sempre dopo aver fatto la cavolata" non ci stanno santi, non c'è modo, ci sono talmente tante cose da ricordare che non ce la fai semplicemente. Sapete che a proposito di questo vi dico questa idea, ditemi se è completamente pazza. Paolo ha sentito il mio talk sull'esplorazione della codebase, no? Alla fine di quel talk, dopo che l'ho fatto risedimentare per qualche qualche mese, mi è venuta in mente un'idea. Una cosa che ho trovato visto che stiamo parlando di documentazione e che spesso la documentazione è sconnessa col codice tolte quelle righe di commento che tu puoi lasciare ma che si basano sull'effetto serendipiti no? cp1 b davanti e ti appaiono le righe di commento che in qualche modo ti spiegano il perché quel pezzo di codice sta là. Ma tolte quelle righe per le quali non esiste un metodo sistematico per raggiungerle, quello che manca, la documentazione che di per sé dovrebbe essere un metodo sistematico per raggiungere l'ignoto, è il collegamento con la codebase. Vi faccio un esempio. Da una parte c'è il manuale con, o il manuale, la documentazione con, la roba che ti spiega il motivo per cui esistono i primordials e subito sotto hai un modo per jumpare ai primordials nella codebase. E' da un po' che sto pensando a una documentazione così, che ti permetta di saltare all'interno del codice partendo dal concetto spiegato. Mi sembra poi così assurdo. No, non è assurdo e questo viene fatto soprattutto per quando magari risolvi un bug o fai una feature relativa a un RFC per esempio, quindi sarebbe molto difficile da spiegare senza avere un contesto il perché hai creato una feature particolare, quindi attraversando il codice su nottrovi_spesso, link a delle issue, link a delle pull request, link a delle RFC che ti vanno a spiegare effettivamente perché quel pezzo di codice è stato aggiunto, perché altrimenti sarebbe davvero impossibile, ma semplicemente perché su una funzione semplice magari ci sono 10.000 casi particolari che richiedono di conoscere un contesto, quindi molto gradito avere un link su cui tu puoi riuscire a capire quello che sta succedendo. Se ho capito bene Mauro, tu parlavi anche del link inverso, quindi dalla documentazione back nel codice. Questo è un po' più complicato secondo me, perché è facile perdere l'integrità referenziale, se mi passi il termine. Quindi io piuttosto che quello... aspetta, cerco di spiegarmi meglio. L'idea è ottima, il problema è realizzarla che è complicato. A quel punto quello che di solito io faccio quando scrivo documentazione e voglio che ci sia un link inverso al codice, non faccio il link al codice, metto direttamente uno snippet di codice nella documentazione, magari anche piuttosto grosso, che quello sicuro non si muove, non si muove dalla documentazione, e si deve sperare che sia comunque un minimo di sync con il codice vero e proprio. E' facile che che è una funzione cambinome, forse è un po' più difficile in una codbase però saccome Node con una funzione sparisca del tutto. Quindi dice "guarda la funzione si chiamava Pippo, non si chiama più Pippo, si chiama Pluto, però la riesco a ritrovare nel codice". Dico "va beh, è la stessa". La documentazione è più o meno quella. Siccome ci stavo pensando, stavo pensando di fare un POC, la mia idea era... l'idea qual era in realtà? L'idea era di puntare al pezzo di codice un commit preciso, ok? E poi volendo con uno slider esplorare la storia da quel punto fino al momento attuale di quel pezzo. Così diventa una figata. Molto figo. Fare il link al commit su GitHub praticamente, con l'hash proprio? Si lo dà esatto, l'hash fa il riga quindi appunto un oggetto di git specifico ah e fa l'embedding ok! Fa l'embedding e con lo slider tu hai la possibilità di spostarti nella storia di git, io te l'ho raccontato negli studi che ho fatto su git, è figa come cosa! E a quel punto tu riesci a fare il link e il link inverso e diventa una figata quando devi fare in DOF anche per i progetti facili al di là di Nod? è da esplorare, ti dico, ti deve esplorare. è una bella idea, proseguila. farevi un'altra domanda, che anche qua è uno dei momenti dove il carico psicologico molto alto in un progetto come Node.js dove il code reviewer è decisamente più alto del collega della media a livello proprio di non voglio dire capacità professionale però cioè parliamo di seniority molto più alta del collega medio. Come funziona il processo di review? Come funziona? Tendenzialmente il processo di review a grandi linee è lo stesso di quello che avviene in qualunque altra azienda, la differenza è che le persone che fanno code e magari conoscono molto molto bene il codice perché lavorano sul progetto da tanto tempo e quindi conoscono anche le implicazioni di quello che il codice che sta scrivendo ah, cioè in Nord ci sono degli esperti di alcune parti di codice cioè per esempio se c'è una pull request sulla parte HTTP ci sarà sicuramente qualcuno che tagga Paolo, tagga Matteo, oppure sugli stream c'è Ronag, diciamo ogni modulo ha degli esperti che vengono chiamati, che vengono taggati e poi il processo di code review alla fine è lo stesso, cioè ti viene suggerito di aggiungere documentazione, ti viene suggerito di aggiungere un commento, ti viene richiesto di fare il refactor di una parte oppure ti viene detto "no, no, guarda, quello che hai scritto non va bene e devi riniziare da capo" oppure dicono "no, questa cosa non si può fissare" e quindi ti chiudono la pull request cioè, è vario la differenza è anche che la qualità del codice tendenzialmente è molto alta cioè il processo di code review è molto stringente Magari ci sono delle issue che sono di poco conto e quindi ci sono soltanto due reviewer o uno a delle volte e quindi per roba di poco conto, però c'è un cambiamento importante, un'afficeria importante, ci sono anche 30 code reviewer, cioè per esempio la parte di Rafael sul Permission Model ha subito un processo di code review lunghissimo ma soprattutto da tantissime persone. Quindi immagina il parere di 20-30 persone diverse sulla stessa parte del codice, magari ognuna con un focus differente, quando tocchi una parte larga della codebase vai a toccare moduli differenti, quindi tante opinioni a volte alcune contrastanti, quindi non sai nemmeno a chi da retta. È vero, è vero perché poi non dobbiamo dimenticare che le persone che lavorano su core sono sia hobbysti ma sia, come nel caso mio e di Marco, dipendenti. Cioè, oggi sono per conto dell'azienda. Quindi è chiaro che parte di quello che ti dicono è la loro esperienza personale, le loro intenzioni personali e parte anche quello magari che serve alla loro azienda, che ne so, non mi tocca starica perché se non il nostro prodotto non funziona più, per dire un'assurdità, no? Ora non mi è mai capitato ma so che è una cosa assolutamente possibile. Il punto è che nelle pull request review c'è una quantità di informazioni che arriva elevata. E so che ti sta a cure l'argomento, infatti te l'ha già tolto il gancione. Per esempio, ecco, Marco ha detto la PR di Rafaella ha preso sette mesi di review da 30-40 persone diverse, ma ha dimenticato di dire la quantità di commenti che ha preso, perché dire 30 questa persona può essere una persona che commenta una volta "amen"? No! Qua parliamo di centinaia di commenti. È una cosa enorme. È capitato anche a me in un'APR che avevo scritto prima in C++ addirittura e poi a un certo punto ho detto "ah, guarda, non serve manco toccare il C++, bastava questa cosa in JavaScript". Quindi l'ho scritta due volte in modo completamente diverso. I commenti della vecchia versione rimangono, anche se purtroppo sparisce il codice, quindi è un po' difficile navigarlo, però più o meno delle cose rimangono. Io nel frattempo ho imparato tante cose sul layer C++ e sul layer JavaScript di Node. A me personalmente a volte triggera la sindrome dell'impostore, perché arriva gente che appunto si ammena dito sul tuo codice e ti devasta, bonariamente, perché loro non hanno intenzioni cattive. Però a te ti arriva che "che cazzo ci faccio io in mezzo a questi?" per dirlo proprio diciamo a un basso livello proprio. Però ci sta, ci sta. credo che il processo inizi e questo tipo di progetti riescano a evidenziare proprio questo concetto di comunicazione, lato code review, a partire dalla creazione della pull request, dal testo a commento della pull request. Io ho delle descrizioni di pull request, tra piccolo spoiler ci sarà presto una puntata /talk su questo, le descrizioni delle pure quest precisi approfonditi che spiegano i dettagli come nei grandi progetti open source raramente li ho trovati altrove e credo che tutto parta proprio da quella descrizione che talvolta è un elenco puntato di feature, altre volte è più concentrato sull'impatto che la pull request dà all'interno della codebase, ma che ha comunque un livello di dettaglio molto alto e quello secondo me il punto di partenza. Vero? Io sono il peggiore in questo, ti posso garantire. Io sono la persona che ti può scrivere 400 righe di codice in javascript senza battere ciglio, se devo scriverne 5 via descrivere la pull request come dio comanda sembra mi stai portando al patibolo. Non ho la ragione però sono una persona brutta in questo perdonatemi. Io devo ringraziare invece il nostro amico e collega Paolo Chiodi che ringrazio a braccio perché grazie a una sua performance review le mie descrizioni della pull request sono passate da caratteri a caso battuti sulla tastiera a elenchi abbastanza dettagliati nella descrizione dell'impatto. Quindi grazie Paolo della tua cazziata sulla performance review. Altra cosa a margine qua, però non è il topic di oggi. Questo è uno dei motivi per cui io adoro le performance review, specie quando ci sono dei lati negativi che vengono evidenziati. Deve essere così. Io lo subito da Matteo sulle soft skills per esempio. Ho lo stesso paragone. Tu immagini io faccio DX, per i primi due anni Matteo mi faceva le performance review e dice "Pa' tecnicamente stai a posto, fai cacare nella comunicazione". C'ho lavorato, c'ho lavorato, c'ho lavorato, adesso faccio DX che è solo comunicazione, vedi un po' tu per assurdo dove puoi arrivare. Sono assolutamente d'accordo con te su questo, in pieno. e subito dopo in realtà avviene la discussione nel thread della pull request. E quello che voglio farvi due domande. Uno, quando la discussione diventa veramente lunga su una feature che è scritto, per le quali hai anche un'affezione, una qualche affezione, che si cerca di minimizzare, come si fa a evitare il sentirsi giudicati? Pur stando magari in una situazione dove i reviewer fanno tutto tranne che giudicarci e lo fanno nel migliore dei modi, nel modo più soft, però comunque la sensazione dell'essere giudicato c'è sempre durante una pour-l'huile, - Sì, è vero, cioè le prime volte magari quando subivo una review con magari 5 commenti cambia questo, cambia questo, cambia questo, poi neat, fai questa piccola modifica, errore di spelling comunque, cioè, dici "cavolo, praticamente non ci ho capito niente io della pull request" però alla fine sul node ci fai un po' il callo, perché secondo me è la normalità. Quando lavori su roba complessa, delle volte fa anche sentire al sicuro il fatto che qualcuno ti dica come fare o come migliorare un pezzo di codice. cioè è anche rassicurante questa cosa perché sai che c'è qualcuno che magari in caso non sai fare un qualcosa ti aiuta. A me mi spaventano di più quelle pull request dove nessuno ti fa la review, dove rimangono senza review appese per tanto tempo. Lgtm, punto esclamativo, quelle sono le più spaventose Luca. Se Matteo se mi sta ascoltando, e spendici le due righe però. Matteo risponde sempre con le GTM e tu dici ma l'ha letto veramente o c'ha il risponditore automatico? Cioè a volte ti viene il dubbio. Ma leggi le piarre. E se glielo chiedo se non le ho lette tutte. E vabbè, figurati. Guarda Geremo faccio ridere Marco. Tu sai che quando fai una piarra arriverà sempre Antoine a un certo punto, giusto? Cioè sempre. Sì sì sì. Meno male. sì sì sì sì sì sì sì sì sì sì meno male meno male cioè Bonareventanto Antoine Duamella adesso pronunciato male tu sei francese dovresti pronunciarlo meglio di noi eh c'è in ogni PR e e se ci stai ascoltando e parli italiano sappi che ti adoro non lo dico negativamente lo dico positivamente io so sempre che qualunque PR arriva e faccio arriverà lui che troverà sempre una cavolo di virgola fuori posto nella documentazione e intendo letteralmente una virgola c'è però io sto tranquillo che non posso scrivere puttana nella descrizione, nella documentazione perché non me ne fa passare una forse neanche la più noioso guarda manca un punto alla fine di sta frase nel commento del codice, quindi potrebbe essere assolutamente inutile non te lo fa passare e tu però stai tranquillo ci va, pure se sei mi soddistratto qualcuno controlla ha ragione Marco, quando nessuno si guarda un'APR la rischi di fare danni che poi su un'APR può fare danni anche devastanti per dire per gestire poi per rispondere anche alla tua domanda a me per esempio nella terza ultima PR commerciato se ne ha creato un problema leggermente diverso nel senso che tutti questi tipo di problemi erano stati risolti e si era arrivati ad un certo punto in cui si era solo da decidere ma sto fix lo vogliamo mettere o no? perché era un fix di un di un utilizzo improprio di express tu immagini, anzi scusami, di una dipendenza di Express e il mio fix andava a risolvere questo problema di Express ma nascondeva l'utilizzo proprio da parte della dipendenza e quindi indirettamente dell'utente. Al che uno dei contributori mi ha detto "sì ma tu risolvi il problema ma legittimiamo l'utente a fare sta cavolata". Non mi sembra il caso. Dovrebbe essere piuttosto Express a sistemare sto problema, tranne che Express, e apro più che dovrei si apre più che da prende faccio il faccio il buon Matteo della situazione ascoltatori non usate express vi prego ce l'ha detto due settimane fa Matteo qua su Gitbar appunto ecco e ancora non lo sento allora l'episodio quello io sto recuperando un po' gli episodi e il punto è cavolo quella cavolo di dipendenza che che espresso tuttora usa l'ultima release è stata otto anni fa non c'è nessuna speranza che quel pacchetto venga mai fixato però non è così. Quindi tu che fai? Fixi node? Cioè fixi node? Ti assicuri che il nodo protegga da staccavolata e poi però l'utente può farlo in altri ambiti o lasci gli utenti morire nel loro brodo perché Express non sistema una libreria? A quel punto qual è la soluzione? Io personalmente circolo a Diplomazia e dico vabbè io Paolo ho quest'opinione tu altro contributo c'hai quest'altra opinione non resta altro che fare sentiamo un terzo parere che disambigua la parità e si fa come dice lui perché c'è un altro modo, perché che fai? Voglio dire, nonostante nei nod ci siano i membri, ecco per esempio un'altra cosa da godere, nonostante sui nod ci siano i membri del TSE, come lo sarebbe Matteo, Raffael, James e così via, e poi ci siamo noi semplici i contributor, se mi passate il termine, non fanno mai per pesare il loro ruolo. Cioè loro discutono della gestione tech, diciamo governance di nod, però quando si è in pull request, review, si è tutti uguali. Il mio parere vale come il tuo. Quindi non è che lui, Angiostronda, arriva il collaboratore e gli dice "Senti, io so, ti assi devi fare come dico io". Non è mai successo. Allora il punto è, io mi sento libero di dire "Chiamo una terza persona che mi dà il parere e me lo disambigua". Cioè dico "Ragazzi, qualche altro collaboratore dia il proprio input così vediamo in che direzione andare". Alla fine la piara è stata mergiata perché poi abbiamo trovato anche una soluzione io e l'altro collaboratore confrontandoci. però c'è stato un il punto è se la La collaborazione produttiva tu vai avanti la butto lì mi raccontava il nostro buon amico michele riva di altre comunità di cui non faccio il nome per privacy tra virgolette di comunità di altri linguaggi programmazione che invece hanno quelle comunità tossiche che ti devastavano e sappiamo tutti chissà perché so già il linguaggio di cui stai parlando non lo dico però ci siamo capiti. Allora, tu non ci metti mano, ti scoraggiano se ne hanno un certo tipo di personalità, non ci metti mano e non collabori e poi il linguaggio rimane magari di nicchia visto che sappiamo di che stiamo parlando. Quello è il problema. Io sono odd dal primissimo giorno, anche quando ero un signor nessuno, ero nemmeno un collaborator, quindi comunque potevo fare PR ma non potevo per esempio emergiarmele, non mi hanno mai fatto pensare il fatto che io fosse un signorne sono uscito dal buco del morese in cui vivo. Su questo sono quindi chi voglio dire le tue parole e devo dire che la comunità che c'è dietro Node è fantastica, cioè le persone che lavorano su Node sono davvero persone che non... anche le cavolate che ho scritte nelle pull request non mi hanno mai fatto pesare, mi hanno sempre supportato, aiutato, sempre col rispetto, quindi non me l'aspettavo, però alla fine se ci pensi persone di un certo tipo, di un certo livello poi si dimostrano anche umanamente molto alla mano. Nel passato non avrei mai detto di riuscire a collaborare sul progetto come noi e adesso che ci sono e vedo anche gli altri, dico che non c'è nessun problema, tutti potrebbero provarci, tutti potrebbero farlo, ma anche perché è la comunità stessa che ti spinge, cioè la comunità che ti dice "sì, apri una pull request, se non ce la fai, ti aiuto io, ti do un suggerimento". Quindi è questa positività che c'è che fa tanto, rispetto come ha detto Paolo ad altre comunità in cui appena scrivi una sciocchezza subito ti attaccano, su Node non mi sono mai sentito attaccato personalmente. Credo che sia a livello strategico la scelta migliore da fare, nel senso che bisogna in qualche modo tutelare la tecnologia, per tutelare la tecnologia bisogna limitare il single bus bus factor o il few bus factor, come possiamo chiamarlo, in quel caso avere delle persone nuove che intanto sono volontari, non è da trascurare questo passaggio che è importante, che dedicano il loro tempo. Poi nel nostro caso, nel vostro caso c'era anche un engagement di tipo lavorativo, perché la vostra società vi finanzia, finanziava quel volontariato, ok? Che era volontariato da parte della società comunque, perché era un investimento da parte della società in quella direzione. E alla fine serve per fare in modo che il progetto possa sopravvivere altrimenti crolla come tanti progetti che abbiamo visto e visto che siamo così impegnati a fare altri sette run time nello stesso tempo. In realtà il punto, se mi permetti di correggere, non è tanto per riservare la tecnologia ma proprio la comunità. La tecnologia va via, la comunità resta. Cioè il team di Nod che se il volesse avresse una comunità sana in cui potessi creare nuovi progetti, sostituire parti intere di node senza battere il ciglio, la butto lì, Yagiz ha appena sostituito, Yagiz, oddio non riesco a pronunciare, comunque Yagiz, un altro collaboratore di node, ha appena sostituito il URL parser di node, da zero, perché? perché si è trovata una comunità sana in cui lo può operare, direi vabbè, se io li propongo di sostituire un pezzo intero di node, loro non battono il ciglio, mi fanno la review, se la cosa va bene, entra, fine. Quindi il discorso è creare quell'ambiente sano, un po' come le società, no? Il discorso, molte società dicono, non è tanto il progetto ma il team. Il team rimane, può finire un nuovo progetto. Il progetto senza il team non serve a niente, cioè sono le persone alla fine. Certo, certo. Su questo aggiungerei anche che per esempio ci sono i working group sono pubblici, cioè i meeting sono pubblici, quindi se sei interessato alla performance o alla sicurezza, come nel mio caso faccio parte del security working group, Paolo mi sembra tu del performance, se vi interessa la sicurezza o la performance, partecipate, ci sono i working group pubblici a cui ognuno può partecipare, può vedere come si lavora dentro un odd, quali sono le proprie iniziative e si può discutere, cioè è molto più facile è molto aperta la comunità, quindi chiunque può partecipare. Questo è fantastico, secondo me. Sì, chiaro. Guardavo l'orologio e il tempo vola e quindi siamo arrivati al momento tipico e topico del nostro podcast. Il momento in cui i nostri host, ma anche il nostro guest, condivide con noi un libro, un podcast, un vino, un articolo, qualunque cosa abbia catturato l'attenzione e che si pensa valga la pena essere condiviso all'interno appunto della nostra community. Quindi la mia domanda è, partiamo da Polo poi Marco, avete qualcosa che vi fa piacere condividere con appunto la nostra la nostra community. Riconducono il paese dei balocchi. Ah il paese dei balocchi. Sì, io racconto un aneddoto agli spettatori di "Insomma a Mauro se tu lo ricordi". È una cosa che gli ho promesso a Mauro avrei fatto in iso puntata e lo farò perché non ho altre idee, vi dico la verità, per motivi personali non sono riuscito a pensarci tanto su quindi vi condivido questa. se siete come noi, oltre a trentenni, più vicini ai quaranta e sentite il peso dell'età che avanza, vi rivelo un medicinale importante che non può mai mancare nella vostra trus da viaggio, ovvero il Gaviscon, perché non si può sopravvivere senza. E vi racconto questa, in una Nier Fest mi disperavo del fatto che non mi ero portato il Gaviscon, non me l'ero scortato a casa. Eravamo alla tavolata di tutti il gruppo italiano di Nierformer, una quindicina di persone. Vi posso giurare che tutti e quindici avevano il Gaviscon in tasca. Ma è compreso. Perché eravamo circa della stessa età. Non c'erano ancora i giovincelli tipo Marco. Quindi, se siete sviluppatori ultra trentenni, Gaviscon, gusto menta nel mio caso, compresso e oro masticabili da 500 mg. Detto fatto, Mauro, te l'avevo promesso. Bellissimo, mi hai portato a galla... un... mamma mia, che bei ricordi. Ciao, siamo divertiti là. Marco, hai qualcosa per noi? Io vorrei citare un po' il talk di Matteo Pollina, quello sul lavorare nell'open source, ovvero di come l'open source possa essere una fonte di carriera. A me ha ispirato molto quel talk perché alla fine lo sto un po' facendo mio, Sto lavorando sull'open source, vengo finanziato appunto per fare questo, quindi vorrei un po' spingere le persone che ci ascoltano a contribuire, a provarci ai progetti che più l'appassionano, o ai tool che usano tutti i giorni, perché alla fine, cioè dietro questi progetti che sembrano chissà che o di una complessità, alla fine sono persone super normali e super tranquille che da qualche parte hanno iniziato e semplicemente poi con un po' di fatica, un po' di costanza sono riuscite a portarle avanti e questo non solo ti dà opportunità lavorative ma ti fa conoscere persone molto importanti e persone che poi ti insegnano tanto e ti danno tanto anche a livello umano. Io sprono a contribuire all'open source. Questo è un po' il mio messaggio di stasera. Che è un bellissimo messaggio e secondo me casca a pennello appunto qua su Gitbar. È di quei messaggi che ripetiamo sempre. Io ho due cose, una non mi ricordo se ve l'ho già condivisa, si tratta di un libro bellissimo, forse ve l'ho già condivisa ma ve lo ricondivido, il libro si intitola "Working in public the making and maintenance of open source software" di Nadia Ekbal è un capolavoro è veramente fantastico questo libro quindi recuperatevelo se avete tempo e poi un altro è un piccolo computerino che è diventato il mio server domestico nel quale ho installato umbrel che non è altro che un'interfaccia grafica a un un docker che con due clic potete lanciare una serie di container che sono utili in casa, che ne so, un Gitea se volete avere un server GIT in casa come ce l'ho io, ho il bitcoin node, full node, c'ho un altro paio di cose. Il computer è un Fujitsu Esprimo Q920 mini, una robina veramente 10 cm x 10, silenziosissimo, consuma pochissima corrente, io ce l'ho nel mio rack elettrico e è una figata pazzesca 8 giga di ram, mezzotera di ssd, viaggio che è una bellezza come computerino domestico, è davvero davvero tanta roba. Insieme a questo però che era una nota a margine, volevo condividere con voi un'altra cosa, se riesco a accedere, perché naturalmente io mica me le preparo le cose, ovvio. Non puoi fare peggio di me, dai che ho improvvisato. Ok, voglio parlarvi di Tailscale. È una roba tipo VPN, un servizio super figo. La cosa veramente figa è che io a il mio socio ho dato accesso al suo account Gmail, quindi con la sua email si autentica, si installa Talescale, si autentica con il suo account Gmail e lui può accedere alla porta esposta dove c'è Gitea. Quindi il mio server non è esposto al pubblico però lui può accedere a Gitea. Non può accedere a tutti gli altri servizi e questa roba mi piace tantissimo. Quindi buttateci un occhio perché secondo me un serverino domestico sta sempre comodo. Come sempre ragazzi io non so perché vengo sempre messo in mezzo in questa cosa probabilmente perché sono l'unico che non si vergogna a parlare di soldi ma non vedo perché vergognarsi a una cosa così bella parlare di soldi perché i soldi sono veramente la cosa più bella del mondo quindi donate perché dobbiamo fare scena da massimo bottura con i vostri soldi quindi è una cosa molto importante e siamo molto poveri quindi donate copiosamente veramente in tantissimi mi raccomando dateci i vostri soldi e noi ne faremo l'uso più responsabile che se ne possa fare ovvero metterli su delle le cripto uscite da mezz'ora. *musica* è arrivato il momento di ringraziare chi si prende in carico Geetbar, chi fa sì che, in qualche modo, possiamo pagare le bollette offrendoci delle birre o attraverso una donazione. Questa settimana sono due le persone che ci sostengo, no? In primis abbiamo Gilberto Macacaro, spero di averlo pronunciato bene, che ci manda un messaggio dicendo alla salute e lunga vita il GITBAR Gilberto da Verona, grazie Gilberto, grazie di cuore e abbiamo anche Alberto Bini che ci offre 5 birre scrivendo spero che questo messaggio vi arrivi, dannato Paypal che non fa aggiungere le dediche volevo ringraziare te e tutto il team di GITBAR per avermi mostrato la mia professione di software engineer con una luce diversa, spronandomi anche a provare nuove sfide lavorative. Grazie per tutto quello che fate e spero che berrete un po' anche alla mia salute. E infatti proprio alla salute di Gilberto e di Alberto noi brindiamo sollevando i calici. Cheers! Bene bene bene è stato super figo andare a esplorare il percorso che hanno fatto Marco e Paolo perché dal mio punto di vista questa cosa può essere come stimolo anche per altri e quindi è veramente importante dirlo in pubblico, condividerlo in pubblico e perché no anche festeggiarlo in pubblico l'achievement ottenuto quindi mi approfitto di nuovo per fare le congratulazioni a Marco e per fare i complimenti e anche i ringraziamenti a Paolo per l'effort che ha messo in questo percorso perché prima del codice ci sono sempre le persone e detto questo noi vi diamo appuntamento alla prossima settimana Ciao a tutti! Grazie Paolo, grazie Marco! Ciao ciao! Gitbar, il circolo dei fullstack developer. Una volta a settimana ci troviamo davanti a due birre e con Brain Repo parliamo di linguaggi e tecniche di sviluppo web, di metodologie e di strumenti immancabili nella cassetta dell'attrezzi dei full stack dev.