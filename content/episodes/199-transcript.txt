Bene e benvenuti su GitBar. Questa sera, questa sera, non so se si può dire sera, diciamo che questa puntata, anche in questa puntata, questa puntata è una puntata, insomma, pirata. Non c'è Mauro, diciamo, che è ancora nel seminterrato a leggere i libri dell'apogeo. Sono tantissimi libri, quindi effettivamente mi sa che ci rimarrà per un po'. Sono in compagnia stasera di Alessio. Buonasera a tutti quanti. E abbiamo anche un ospite speciale. Ci tengo a precisare, poi, intanto qui non facciamo editing, quindi lo dico e lo nego. Per chi stiamo seguendo, perché stiamo invitando un sacco di gente di Suse? Non è perché è il podcast di Suse, cioè nel senso qui 3 su 3, insomma, ma nel senso, quindi questo potrebbe essere così, ma se tutti quelli forti stanno a Suse, io non ci posso fare niente, nel senso abbiamo questo piano editoriale così. Quindi, signore e signori, vi presentiamo Flavio Castelli. Ciao Flavio, chi sei, che cosa fai? Ciao a tutti, sono Flavio, e niente, mi occupo, sono in Suse da parecchio tempo, Ho fatto di tutto, di più, ho toccato vari argomenti e da un po' di anni a questa parte sono partito per quella che è la tangente di Linux container poi con l'evoluzione dell'orchestrazione con Kubernetes e ultimamente mi sto occupando di sicurezza nell'ambito di Kubernetes e poi ho questa passione per WebAssembly e lato server che sto cercando di portare avanti anche quella. Che bello! Che bello, ragazzi. Questa è una cosa interessantissima. Io parlo da persona estremamente profana dell'argomento. Io mi ricordo ancora quando scoprì cos'era WebAssembly e vedi questo articolo su Hacker News, che c'era la demo del giochino che era fatto con United, che però era nel browser, no? Quindi era bello, fluido, si dice, ah, chissà quante cose si possono fare. E diciamo, come si arriva, ecco, facciamosi proprio con la prima domanda a bomba. Innanzitutto, per chi non lo sa, che cosa si intende per WebAssembly e che cosa ci fa questo WebAssembly sul server? perché spesso siamo abituati ad associarlo al frontend. Diciamo che poi anche tutto il mondo JavaScript, diciamo che questa cosa non aiuta, noi stiamo parlando in questo momento e stanno comunque nascendo altre due, tre framework, probabilmente anche che utilizzano WebAssembly. Quindi che cos'è WebAssembly e soprattutto come ci finisce sul server? WebAssembly ha avuto la nascita come metodologia per estendere il browser e quindi per renderla un pochino più semplice, poi ditemi voi, diciamo che è una target di compilazione io scrivo un programma in un linguaggio di programmazione per esempio, un esempio amato da tutti, in C tutti amano scrivere in C ovviamente e poi compilo il mio codice per il sistema operativo e per l'architettura su cui voglio far girare il mio programma qui parliamo di un eseguibile, potrebbe essere anche una libreria condivisa però il fatto è che tu hai un compilatore, prendi l'input del codice sorgente e in output hai dei binari per una specifica architettura e sistema operativo WebAssembly è praticamente un target di compilazione per il compilatore il che vuol dire che io posso prendere questo codice che ho scritto per esempio il gioco scritto in Unity non sono così a dentro però invece che avere un binario compilato per Linux per x86-64 ottengo invece un binario con il bytecode di WebAssembly che è un po' come il bytecode della JDM, per dire di Java e questo binario lo posso prendere e eseguire all'interno della virtual machine (non inteso una macchina virtuale per un sistema operativo, ma una macchina virtuale come la JVM) e posso farlo girare su qualsiasi sistema operativo e su qualsiasi architettura che vuol dire che io posso compilare questo programma sulla mia macchina Linux x86-64 e poi dopo Alessio lo fa girare su una macchina Linux ARM64 e tu Carmine lo fai girare su Mac Architecture ARM il tutto senza la necessità di andare a ricompilare il tutto. Questo è uno degli scopi di WebAssembly perché quando ho un'applicazione web, il WebAssembly viene fatto girare anche nel contesto web lato client, quindi sul portatile di chi sta visitando il mio sito internet, e quindi non è concepibile che io mi metta a creare N.000 artefatti binari per Android con la tale architettura, iOS, Windows, Linux, Mac, etc. Quindi è un concetto di portabilità. Il layer che va a fare la traduzione tra quello che è il binary code e il sistema operativo è appunto dove c'è tutta questa complessità della portabilità, è l'Argument Time di WebAssembly. e poi bloccatemi pure, io sto andando a braccio ecco vai vai no vai vai vai io ovviamente ho tipo, cioè mi sale subito la scimmia ma è possibile estendere la run time dei WebAssembly? Sì, decisamente, questo è una cosa anche molto facile da fare C'è una specifica di WebAssembly che copre il livello base del linguaggio e tutta una serie di aspetti collegati però per esempio nella specifica core tu hai i dati che sono interi e numeri in virgola non hai nemmeno per esempio stringhe o altro e dopodiché tu puoi definire per esempio, di fatto se tu guardi l'Hello World più banale di WebAssembly è lo WordArc ora, ok? Cioè proprio per chi vuole scriversi l'assembly a mano e anche lì c'è tutta una cosa interessante ma vabbè, non divaghiamo troppo. L'esempio più semplice è quello di scrivere per esempio una funzione creare un modulo WebAssembly che è una libreria che espone una funzione che può essere invocata da chi lo usa e questa funzione somma due numeri dati in ingresso e restituisce appunto la loro somma. e il problema è che ovviamente non ci fai tanto andando con queste primitive di basso livello e quindi tutta una serie di altre funzionalità vengono aggiunte a quello che è il... come si dice? a quello che è il run time per permettere di fare operazioni più interessanti dal fatto di riuscire in qualche modo a maneggiare in ingresso e in uscita dati più complessi quindi stringhe, rappresentazioni di oggetti, tipo liste, dizionari o altro, oppure andare addirittura ad esporre una serie di funzionalità che per esempio potrebbero essere quelle di andare a operare con dei file su hard disk, quindi tornando un attimino a quello che era l'esempio il caso d'uso iniziale, scriviamo "hello world" in C, e nell'hello world in C io effettivamente faccio tipo una printa, però il fatto di fare una print implica che io abbia accesso a un device, lo standard output su cui andare a stampare e questo non è una cosa così banale, questa nella specifica base di WebAssembly non c'è e poi c'è un'altra specifica che lo va a arricchire, che è la specifica OASI WebAssembly System Interface che va a ricreare un po' quello che è lo standard POSIX ma non vogliono implementare i POSIX nel mondo di WebAssembly, in questo caso però non siamo più tanto... si può fare anche nei browser, però diciamo che diventa più un aspetto per far girare il tutto al di fuori del browser e quindi lì puoi fare sì che quando il tuo codice viene compilato il tuo codice va a utilizzare la direttiva printf viene generato un modulo WebAssembly che poi al momento del run time, quando viene importato va eseguito dal runtime importa delle funzioni esterne che gli deve dare al runtime è un po' come quando vai a fare il linking di una serie di librerie insieme e si devono risolvere dei simboli in questo caso i simboli importati vengono offerti dal runtime e quindi ci sono una serie di simboli, di API che sono standardizzati, o sono in fase di standardizzazione e che vengono fornite dai runtime. Oppure puoi inventartene tu di tue, ok? In quel caso però il runtime, non puoi prendere un runtime qualsiasi, ma deve essere un runtime che parte dalla base, diciamo, e poi viene steso per soddisfare anche questi questi simboli extra, mettiamola così, sta andando forse un po' ok. Ok, quindi alla fine diciamo, possiamo dire che è una cosa portatile, però diciamo ad un certo punto devi necessariamente sapere che cosa stai scrivendo, cioè nel senso, ora non lo so, sto parlando proprio da totale profano, se il mio obiettivo è far andare diciamo questa parte di WebAssembly nel browser, molto probabilmente non è che posso fare questo server, questo web server nel browser, insomma. Cioè, nel senso avrò comunque delle limitazioni che sono imposte comunque dalla piattaforma stessa in cui sto facendo... Anche perché è sandboxato. Esatto, quindi nel senso devo comunque chiedere l'accesso a determinati permessi. Cioè, nel senso, se io penso a ciò che viene eseguito nel browser, se devo vedere la webcam, Io devo personalmente... Ah, un saluto a Leonardo che è qui con noi. Ciao Leonardo. Ciao a tutti, buonasera. Ciao Leonardo, allora ti catapulto subito una cosa. Stiamo parlando di WebAssembly, WebAssembly sul server e sul browser e la mia domanda era, ma se io eseguo una parte di WebAssembly nel browser, no? Dovrò comunque chiedere una serie di permessi. Ad esempio, se voglio utilizzare la webcam, il micro ha chiede il permesso. Non è che se faccio questa cosa in WebAssembly, allora ho accesso automaticamente a tutto e posso bypassare questa serie di cose, immagino. Ok, quindi ho comunque la necessità di... cioè non so come funziona. Allora lato web non sono un super esperto perché sono sempre stato una persona da back-end infatti anche per quello che l'ho scoperto recentemente. A prescindere comunque sì, allora il fatto è che il tuo codice WebAssembly deve essere stato scritto, questo a prescindere, importando una serie di librerie che poi danno accesso a queste altre funzionalità che possono essere la webcam, il microfono, l'accesso a un file oppure anche semplicemente un metodo per scambiare dati input e output per esempio avere un JSON in ingresso e restituire un JSON in uscita della sandbox di WebAssembly poi il fatto di usare queste librerie fa sì che il compilatore quando poi va a generare il modulo WebAssembly andrà a inserire tutta una serie di direttive di import che devono essere risolte dal run time nel caso del browser c'è una serie di codice che fa da colla che è scritto in javascript che va a fare il binding o... come i figli lo dicono? il polyfill forse? tra quelle che sono delle API esposte standardizzate dai vari browser per la webcam e altro, e invece quello che si aspetta la libreria che è stata scritta per poi essere usata nel modulo WebAssembly. Di conseguenza nel momento in cui il polyfill, questo bridge, dice "io voglio accedere al microfono per conto di WebAssembly, ma non lo sa il browser che è per conto di WebAssembly, allora poi ti arriva, immagino, il tipico pop up del browser che dice "per mettere l'accesso alla webcam". Ok, ok. E quindi se invece ci spostiamo sul server, no? Esatto. Se io sto scrivendo qualche, se lo sto scrivendo in Rust, no? Perché in Civo ormai non ci posso mai avvicinare, non che il Rust sia questo grandissimo esperto. ma quindi tutte, cioè se io voglio importare una libreria Rust, che cosa del linguaggio può percolare all'interno di WebAssembly? Ad esempio, se sto scrivendo una cosa che fa, non lo so, tutta la parte diciamo a sync di Rust, quindi che sia con il standard o che sia Tokyo, insomma, - oppure magari voglio... - Un po' di spagnolo di sangue diretto. Ecco, sì, no, alla fine, che cosa perco ha del linguaggio dentro il passivo? Oppure magari lo sto scrivendo in Go, in Go posso sponare una goroutine e fare cose, ho i channels, tutta la concorrenza sul modello CSP, che non c'ho, non ce l'ho scritto. Come funziona questa cosa? Si porta dietro tutto, quindi posso fare questa goroutine? Oppure no? Non funziona. Al momento no. La risposta diretta e netta è questa. La specifica WebAssembly per esempio non prevede il supporto dei thread nel core. C'è un working group che sta lavorando per l'implementazione del tutto. Onestamente non è un aspetto che sto seguendo così da vicino perché per quello che faccio con WebAssembly in questo momento non mi tocca. Quindi per esempio non puoi prendere delle librerie async e farli girare all'interno di un target WebAssembly. Questo è un esempio. E quindi nel momento in cui funziona così che Work in Group delinea delle specifiche che vanno ad arricchire quella che la specifica corra. Vengono poi fatti diversi, adesso spero di non dire troppe castronerie perché non sono così addentro nel processo di standardizzazione. però vengono fatte una serie di revisioni di queste specifiche e poi c'è un'implementazione di riferimento per testarla e dopodiché, per essere graduata stabile, penso che questa implementazione debba essere distribuita almeno in un run time. Penso, però qua ribadisco, non sono così a dentro. e quindi se io volessi andare su per bleeding edge e provare a sfruttare la proposal dei thread di WebAssembly per compilare del codice Rust, dovrei molto probabilmente andare a lavorare su quello che è il compilatore Rust in modo tale da arricchire tutta la pipeline di compilazione in modo tale che abilitando delle feature speciali, per esempio quella del supporto trading riesca a tradurre una serie di codici RAS in quelle che sono le direttive di basso livello previste da questa nuova specifica di WebAssembly. Dopodiché, una volta che ho questo mio modulo WebAssembly, per farlo girare, dovrei far girare all'interno di un Runtime WebAssembly che nel momento dell'istanziazione abbia innanzitutto la feature del threading attiva, cioè implementata, ma soprattutto attivata. Altrimenti ci sarebbero tutta una serie di funzionalità di import, prevedo, che non verrebbero risolte e quindi non funzionerebbe il tutto. Facciamo un passo indietro, e questo è una cosa, perché già mai detto tanto. Questo è un target di compilazione, quindi io faccio make e più o meno ho il mio punto WASM alla fine della cosa. Ma esiste un modo, questo è proprio domanda stupida, per farlo girare senza metterlo all'interno di un altro programma? Cioè nel senso, io ho il mio punto WASM puro così e WebAssembly che io sappia, da quella paginetta che mi sono letto più o meno, funziona tipo chiamata risposta, no? cioè tu hai delle funzioni che esponi, ma non c'è un tool, una riga di comando che io posso chiamare per eseguire il main di questo WASM? Allora, diciamo che quando parliamo di Runtime WebAssembly, la cosa molto carina è che ci sono varie implementazioni e tutte quante si posizionano praticamente nell'essere delle librerie per esempio WASMtime, che è l'implementazione di riferimento che è portata avanti dalla Bytecode Alliance una fondazione in cui ci sono diverse organizzazioni che contribuiscono allo sviluppo di WebAssembly. È una libreria scritta in Rust. Dopodiché ha dei binding per varie linguaggi di programmazione. Ma così anche tanti altri runtime. Moltissimi di questi runtime poi creano un loro main, all'interno del quale importano la loro libreria. e per esempio WasmTime, oltre a essere la libreria, ti dà un combinario che si chiama WasmTime dove puoi fare WasmTime run e gli dai in pasto il percorso file.webassembly che deve essere un modulo WebAssembly compilato per il target WASI e se tu all'interno di quel modulo c'è scritto il tuo print hello world tu fai "wasn'time run hello.wasm" e sullo schermo vedi "hello world" "hello world" esatto idem, se per esempio tu all'interno hai scritto del codice che va a leggere dei parametri per esempio hai fatto un main che ha tutto il suo parsing degli argomenti della CLI anche con i subcommand, le cose più complicate che ti puoi immaginare e magari va a leggere dei file dall'Hardiska e poi li risputa fuori salvandoli da un'altra parte sullo standard output quando tu fai WasmTimeRun gli devi dire, per esempio, a parte che tu puoi fare tutti i vari flag che metti dopo il nome del file, quasi vengono passati al tuo programma se non ricordo male la configurazione di default di WasmTimeRun ma poi dopo devi dirgli che cosa facciamo a vedere del file system del host al guest? Cioè al tuo modulo. Perché è sandboxato. Esatto, perché è sandboxato. Praticamente sempre per via di questo passato nel browser, che è un contesto altamente insicuro nel senso, fonte di pericoli, cioè se tu ci pensi alla fine tu ti scarichi un binario da un sito internet e poi lo esegui sul tuo computer all'interno del runtime che è il tuo browser Sicuramente esistono già crypto miner in WebAssembly Ah sì, sì, sì Una per Sky, altre per Zidaci, certo E quindi il fatto è che per motivi di sicurezza è stato disegnato proprio tutta la specifica WebAssembly per essere eseguito all'interno di uno sandbox non ha visione quindi del processo all'interno del sandbox degli altri processi sul tuo computer non accesso la rete, non accesso i file system e quindi sei tu che devi gradualmente, è un po' come un container, un linux container dove dici ok sta girando senza network oppure sta girando solo con i file system che il suo non vede niente dell'host e così gli dai le capabilità. Esatto, la cosa molto interessante di WebAssembly, ho detto una parola interessante, è il fatto che si può arrivare addirittura ad avere un controllo estremo di quelle che sono le capabilities. Per esempio, io posso dire, creo un framework per lo sviluppo di applicazioni web, lato server, quindi back-end. Mi iscrivo una FAS, faccio una piattaforma FAS che utilizza codice che è compilato in WebAssembly. E poi questo codice fa le cose, diciamo, si passa nel termine tipico di un back-end quindi riceve delle richieste HTTP in ingresso e poi per esempio va e scrive dentro un database key-value store io posso dire, identifico la possibilità di leggere all'interno del database key-value store con una capability del mio framework e identifico la possibilità di scrivere con un'altra capability e poi dopo si può dire a runtime, che è a questo punto runtime customizzato su quale abbiamo costruito, siamo partiti dalla libreria di Wosentime per esempio e poi ci abbiamo aggiunto una serie di feature che interessano a noi possiamo dire, ok, nello stesso modo in cui decidiamo che capabilities dare per esempio su File System o altro, andiamo a fare un tuning super ottimizzato delle capabilities che sono, non so, il Key Value Store che possono essere fare richieste HTTP puoi dire le puoi fare, non le puoi fare, le puoi fare solo di questa natura post, get, verso, quali, host e quant'altro. Quindi c'è in questo momento un correre alla creazione di questi framework di sviluppo che hanno questo per applicazioni completamente nuove, greenfield development, dove vai ad abbracciare questa idea anche di avere un modalità d'accesso a capabilities molto precise. Infatti tu quando prima hai parlato di JVM, ora ti do la parola Leonardo, in solo un secondo per finire questa cosa. Quando hai parlato prima di JVM il motivo per cui io ti ho chiesto se si poteva estendere il runtime era che io mi immaginavo chissà se si può fare qualcosa per fare più che la JVM, tipo la BIM, cioè offrire a un utente a quel punto tutta un'infrastruttura che te consente di impostare anche long running process tipo genserver, cose del genere, in modo che uno a quel punto ci si piazza sopra e fa anche cose molto elaborate con relativamente poco codice o comunque orchestrando tutto il runtime più che andando poi a spawnare thread a mano. Io volevo chiedere, visto si parlava di richieste di network e database, poi sono entrato proprio nel momento in cui si parlava di asincronicità, che comunque quando in WebAssembly si può scrivere su un server, però è tutto sincrono, quindi si scrive, si aspetta la latenza, si torna in dieta e dà la risposta, quindi nel mentre non succede nulla, giusto? Sì, diciamo che la sincronicità può essere introdotta per esempio dal lato run time dove io poi ho un web server che riceve le richieste di ingresso e poi di fronte a una richiesta arrivata su un determinato percorso può anche fare lo spawning immediato di una sandbox all'interno della quale gira il codice WOSM che prende i suoi dati, li mastica e poi li restituisce. E questo in WOSM Time allo specifico è tutta una serie di funzionalità a sync per cui quando il guest è in idle, non sta combinando un grand key, ogni tanto lo mette in pausa per far gestire a Tokyo tutto il discorso. Per fare questo spawning c'è un problema di cold start? Allora, diciamo che è molto rapido l'avvio volendo tu puoi mettere anche tutta una serie di... dipende un po' da come è descritto però ci sono... allora, funziona che tu hai il modulo WOSM, che è il bytecode generico di WOSM dopodiché, prima di farlo partire il modulo deve essere ottimizzato per il sistema operativo e per l'architettura su cui si va a eseguire e quindi questa fase di ottimizzazione del codice richiede più o meno tempo a seconda delle dimensioni del modulo del file e a seconda del livello di ottimizzazione che vuoi fare però è una cosa che fai una tantum è da rifare nel momento in cui, per esempio, stai usando Wosentime versione 22 esce la versione 23, magari lo vuoi ricom... in teoria, se non ricordo male, sono addirittura compatibili cioè ottimizzo con la 22, lo faccio gira con la 23 se non ricordo male lo supportano però diciamo che in quel caso non farebbe male andare a fare il refresh comunque, ritornando all'esempio di prima del web server io alla Dio so già quali sono tutti i miei moduli che ho in pancia mettiamola così proprio grezza li ottimizzo tutti quanti e poi dopo, al momento delle richieste, faccio partire la sandbox e in quel caso il tempo è veramente ridotto. Se poi ci dovessero essere delle inizializzazioni molto particolari fatte una tanto all'avvia del programma, come per esempio andare a fare la compilazione di regular expression o altro, si possono andare a mettere all'interno di una determinata funzione che se non ricordo male si chiama init, non ricordo bene il nome, e ci sono un po' di barbatrucchi per fare delle sorte di snapshot. Quindi tu fai partire l'istanza già ottimizzata, viene eseguito il codice di init che si inizializza tutto quanto, lo metti in pausa, come uno snapshot in una macchina virtuale di un sistema operativo, e poi dopo, quando fai lo spawning, lo fai da quello stato già... - Frizzato e scongelato. - Esatto. Per ridurre ancora di più le tempistiche. Interessante, figo, ci sono delle cose che sono collegate Dipende tantissimo, un altro dei punti chiave è il supporto da parte del linguaggio di programmazione che stai usando per scrivere il programma nei confronti di WebAssembly Rust ha un supporto ottimo per produrre codici guest WebAssembly Go, per esempio, o un po' di meno, il Go compilatore ufficiale supportava WebAssembly come target di compilazione da tantissimo tempo ma aveva come target di esecuzione non il lato server ma aveva il browser, quindi c'era, quando tu tuttora puoi compilare del codice Go in WebAssembly per farlo girare dentro il browser questo era l'unica modalità supportata un tempo e questa produceva oltre a file puntuose ma anche un file javascript con tutto quel codice di colla che andava a supplire a tutta una serie di funzioni che il codice, il modulo WOSM prodotto dal compilatore ufficiale di Go andava a richiedere a runtime, andava a importare a runtime da parte dell'host e c'era tutta una serie di funzionalità che erano implementate era come dire l'implemento delle funzionalità di Go, di Go linguaggio ma l'implemento in javascript perché il compilatore non ha prodotto queste funzionalità all'interno, non può farlo. E quindi dipende un pochino anche da quello, il fatto per esempio c'è Swift, che è interessante come linguaggio, non so quanto ci abbiate mai avuto a che fare, però... poco però ero interessato alla cosa perché avevo anche visto i linguaggi supportati da Joe Borden, di cui poi spenderemo penso qualche minuto e avevo visto che c'era anche Swift supportato. Mi ricordo quando l'hanno presentato che era il nuovo linguaggio di programmazione per la piattaforma e Osprey diceva "noi con questo vogliamo che sia un linguaggio di programmazione universale che ci svolgeva il browser e poi sono passati credo una decina d'anni non so a che punto siamo arrivati. Allora non lo seguo da vicino conosco un paio di persone che sono un po' che sono entusiaste del tutto. Io non ho mai sentito parlare al di fuori dello sviluppo IOS per esempio. Un po' quello è il problema secondo me nel senso che funziona anche tranquillamente su Linux, su Windows per produrre dei binari, delle librerie. Il Il problema è che quando mi ci sono cimentato per apprenderlo, quello che si trova come documentazione, sia ufficiale che è, è tutto come target quello all'OS. L'unica cosa che avevo visto all'epoca era che ci stava un framework web che era Vapor, mi sembra che si chiamava, e era tipo l'unico framework web che ci stava per Swift. Swift per esempio compila tramite un compilatore che è mantenuto da community, è basato sul compilatore open source di Apple con delle patch che piano piano stanno ritornando upstream. Però per esempio nel caso di Swift i binari compilati in WebAssembly hanno un peso megalodontico per il mondo WebAssembly. Perché un'altra cosa interessante di WebAssembly sono le dimensioni. Per darvi un paio di riferimenti un modulo WebAssembly in Rust arriva a pesare 1,5 o 2 MB se tu prendi un modulo Swift, al tempo, arrivava a pesare 16 MB quindi veramente tanto e ci sono anche una serie di ottimizzazioni la cosa carina è questa, che essendo comunque un binary code portabile è un binary code, quindi poi hai una serie di ottimizzatori per ridurre le dimensioni del binario migliorare l'esecuzione come velocità che sono agnostici del linguaggio di origine perché vanno a fare delle ottimizzazioni un po' come il compilatore nelle fasi finali della compilazione va a ottimizzare il binario prodotto hai questi tool che ottimizzano un file web assembly e ne producono un altro che magari è più piccolo come dimensioni, perché magari Swift di default ti genera tutti i simboli di debug e non c'è modo per stripparli, invece tu puoi farlo con un altro tool. Però ecco, dal punto di vista del cold start per ritornare un po' all'origine di questo excursus, dipende tanto anche dal linguaggio di programmazione e dal supporto che ha. L'ottimizzazione a cui tu ti riferivi viene applicata al suo urgente, che poi viene passato al compilatore che compila la cosa oppure direttamente all'artefatto? All'artefatto finale. Quindi io posso prendere un codice scritto in Swift, lo compilo con il compilatore Swift e ottengo un modulo, un file WebAssembly. E poi uso un tool che si chiama WozomOpt, che fa parte di una suite che si chiama Binarian, che magari chi è nel mondo JavaScript ci ha avuto a voler fare per qualche altra cosa. ancora no purtroppo e questo ti ottimizza il modulo WebAssembly te ne produce un altro che magari occupa meno spazio o che è più veloce in esecuzione e quant'altro mamma mia perché la giornata non c'ha 67 ore adesso voglio fare anche questa cosa e quindi adesso io che voglio mettermi a smanetta con WebAssembly da dove inizio? - Devo chiederlo io, perché scusami, non avendo preparato un balocco, ho detto "faccio il balocco al contrario" e gli ho chiesto a lui di propormi il balocco durante il "Cosa di Balocchi", però me l'hai bruciato, quindi... - E niente, dò frega. - Però volevo sapere, in effetti, quali potrebbero essere le risorse, dove partire, che possono essere magari playlists su YouTube, corsi a pagamento, libri o... Allora, dipende da cosa vuoi fare, sto pensando. Come libri c'è... O farsi assumere come programmatore junior WebAssembly, per cui siamo stretto. Tutto è in fase di divenire, è un mondo che sta esplodendo adesso, quindi a livello di letteratura, come libri scritti, per esempio. Ah sì? Perché se senti parlare a tanto, però mi dici che forse sta diventando un po' "mainstream" solo ora. Diciamo che nella curva del mercato degli early adopters stiamo entrando nella fase in cui abbiamo superato lo scoglio iniziale degli entusiasti, quindi c'è gente che lo sta anche utilizzando in produzione, però siamo oltre gli early adopters, però di strada a mio avviso ce n'è ancora un po' da fare. Detto questo, quindi quello che si trova in giro come libri, ci sono dei libri che ti danno un'infarinatura magari anche un po' a basso livello su quello che è WebAssembly e come funziona. Se ti vuoi arrivare proprio a, come dire, Arcore, a vedere le cose a basso livello, c'è un libro, la sto guardando adesso, della Nostarch Press, che si chiama "The Art of WebAssembly" che secondo me è molto carino, mi è piaciuto tanto. Disclaimer, è pensato più che altro per il browser, però Mounkwis approccia a WebAssembly un approccio di basso livello e quindi non è niente male. Altrimenti, come altro libro carino, Stavo cercando... a me piace tanto come casa vendutrice la Pragmatic Bookshelf ok, le PragPod c'è il libro di Kevin che adesso cerco vai vai "Pragmatic WebAssembly with Rust" e poi c'era un libro che avevo iniziato a leggere in beta della Orilli che ha in copertina un cagnolino buffo, piccolo, peloso, cercate WebAssembly dell'Orilli, lo trovate non era male però, adesso non ricordo, per me era un po', dopo averme letto male Sono tutte e tre i libri, per esempio, ricollegandoci che sono una del 2019 e gli altri due del 2021 e ora li posso comprare online, quindi non ci sono altre edizioni. È cambiato qualcosa nel frattempo? Allora, diciamo che questi sono dei libri che ti spiegano un pochino com'è WebAssembly, ma onestamente non ti mettono in grado di andare a scrivere un handler, una FAS che utilizza WebAssembly. Questo perché qua siamo proprio nella strada dei pionieri, quindi non c'è niente di discreto al momento. E lì il problema cos'è? Che di base, come dicevo prima, la specifica WebAssembly non aveva fino a non molto tempo fa un modo per stabilire, per esempio, come gestire dell'input da una chiamata HTTP in ingresso, perché non c'era uno standard per fare tutto questo. Quindi sono creato una serie di framework che sono andati a prendere un run time e stenderlo con tutta una serie di funzionalità per fare il tutto. E qua c'è un po' la competizione tra quale sarà la startup che vincerà, diciamocela così. Anche perché quello che può essere un po' a rischio è che alla fine uno vada a vincolarsi a quella che è un framework che ha utilizzato per scrivere l'applicazione e poi si ritrovi costretto a girarvi ci sopra. Ci sono dei modi per riuscire a evitare che tutto questo accada però penso che richiederebbero un po' di sforzi. Detto questo, i nomi che mi sento di dire, secondo me, sono molto di parte però la mia raccomandazione sarebbe di guardare InSpin che è un progetto open source di Fermion che offre un modo di scrivere ti permette di scrivere codice per gestire chiamate HTTP in ingresso ti fai la tua FAS e scrivi con la loro SDK che è molto ricca e ti permette oltre a un discorso di gestire payload in ingresso HTTP che permette anche di andare a interagire con un database, con un key value store o di andare addirittura ad accedere a funzionalità di machine learning che è molto interessante anche quello - Ammazza, pay gap nel run time, sta cosa - Sì, sì, sì ed è molto interessante quello, adesso hanno anche creato un operator, apparentemente, in tutto il mondo di Kubernetes, come si coniuga con WebAssembly di cui se volete poi possiamo anche parlare. E quindi lì puoi far girare tutto stand alone, tutto portatile, puoi farne un deployment dentro Kubernetes e quant'altro. Hanno degli ottimi tutorial e dell'ottima documentazione. Un altro progetto che secondo me varebbe la pena di guardare è Wasm Cloud, che è un progetto, anche questo open source, è addirittura dentro la Cloud Native Foundation e diciamo così, fa le stesse cose, la mission è quella, è il fatto di andare a scrivere applicazioni web lato back-end ovviamente, che girino con moduli WebAssembly. Questo è un po' quanto. C'è molta collaborazione comunque tra questi progetti, molta sinergia, La cosa interessante è che si sta lavorando all'interno di vari working group per andare a stabilire quelle che possono essere delle API standard per andare a effettuare una serie di operazioni in vari contesti. Per esempio nel contesto cloud, come viene chiamato, di scrivere quelle che le API per fare una richiesta HTTP, per ricevere una richiesta HTTP, per interagire con un key value store. La cosa estremamente interessante a mio avviso di tutto questo è che per esempio io posso prendere, avrò un SDK che mi dà quindi delle funzionalità per andare a interagire con un Key Value Store. Escrivo il mio codice affinché vada a fare operazioni di scrittura e lettura nel Key Value Store. Dopodiché al momento del run time, momento dell'esecuzione, è il run time che va a creare il bridge tra quello che sono le funzioni importate dal guest, quindi tipo voglio scrivere la chiave fu con il valore bar dentro il key value store e quella che è l'effettiva implementazione. Quindi cosa succede? Che io posso avere a livello operation posso configurare per esempio che il key value store da utilizzare in questo contesto è un Redis che gira all'interno del mio cluster Kubernetes sull'edge. Mentre quando vado a fare il deployment in un public cloud posso invece andare a utilizzare un key value store tipo Cosmos, DB, Azure e la cosa interessante è che il guest, il codice che io ho scritto, non deve essere ricompiato perché c'è un'interfaccia, una strazione, che dice "scrivi questa chiave con questi valori, punto, ok" poi come viene fatto è una cosa che spetta a run time e quindi questo, secondo me, dà molta flessibilità e opera scenari interessanti Sovrano diventano upstream, nel senso che ho estensioni custom, è in conto, però quando comincia a diventare più rugged, più battle tested, la situazione è interessante. Bellissimo. Un'altra delle promesse che danno è il fatto di spostare, per esempio, alcune tematiche di sicurezza, per esempio, interagire con un Redis, magari mi richiede comunque, mi richiede anzi di avere un supporto TLS abilitato. Nel momento in cui c'è una vulnerabilità di OpenSSL non è che io debba ricompilare tutti i codici guest che ho. Io semplicemente devo fare il deployment del runtime patchato. Certo, ma come si estende il runtime? Nel senso, c'è la libreria, quella che è quasi quella che usate voi su Rust per esempio? Quasi uno standard che descrive un sistema di API per interagire con alcuni aspetti POSIX, per esempio uno standard output, standard input, file, socket addirittura recentemente e quant'altro. Se io voglio invece andare a... comunque il modo con cui funziona tutto questo è lato runtime, allora tutto parte... sono molto avvezzo a quello che è il modo con cui funziona Wosentime. Voi sentate una serie di oggetti C'è l'oggetto engine che è colui che va poi in runtime a eseguire il tutto Tu hai un modulo il modulo è praticamente gli dai un pasto al tuo file.webassembly e crea un oggetto modulo dato un engine come parametro sul quale andrà a funzionare Questo è interessante perché poi ci sono tutta una serie di funzionalità che si possono andare ad attivare sull'engine che vanno a cambiare il bytecode del modulo WebAssembly. Per esempio, se voglio mettere dei limiti sullo montare di cicli di CPU che vengono utilizzati o di memoria o un discorso di esecuzione a livello di tempo, tutto questo viene fatto andando ad alterare quello che era il modulo WebAssembly in ingresso. Per esempio, non so quanto non sono in queste cose, però la blockchain, tutto il concetto di fuel per andare a comprare, ecco, c'è un pochino questo concetto di fuel anche nel mondo WebAssembly, se vuoi abilitare. Per cui dici, io ti do tot carburante al tuo codice, una volta che è finito quel carburante, e poi decido se farlo proseguire o meno quindi hai il modulo creato sull'engine e dopodiché vai a creare un linker e qui le cose diventano interessanti perchè poi sul linker tu vai ad esporre delle funzioni che vai a esporre al guest in questo caso tu scrivi delle closure diciamo così, lato host che poi vengono eventualmente invocate dal guest quindi se io dal guest lo estruisco in modo tale che dica a runtime io faccio un import da runtime di una funzione che si chiama abs, che calcola il valore assoluto che ha un API che prevede in ingresso un intero e prevede in uscita come valore di ritorno un altro intero Nel mio runtime all'interno del linker vado a definire una funzione che ha quella signature precisa e poi scrivo un blocco di codice Rust o se uso dei binding in Go per Wozentime lo scrivo in Go che va a prendere questi dati che gli arrivano dal guest tradotti in tipi nativi del linguaggio di programmazione che si fa sulle sue operazioni e poi restituisce il valore e poi sta a run time il fatto di andare a tradurre poi questo valore e passarlo sotto al guest quindi tu crei una serie di funzioni all'interno del tuo linker volendo potresti avere... c'è anche un concetto che si chiama... lo state che ovviamente è una cosa che ti permette di tracciare mantenere la persistenza di alcuni dati e dopodiché tu hai lo state, hai il linker il linker è stato creato a partire da un modulo WOSM e puoi istanziarlo in quel momento tu hai un oggetto istanziato che poi dopo, questo oggetto che si chiama instance ha una serie di funzioni, tra cui c'è una funzione che si chiama call e puoi fare una chiamata di una funzione esportata dal guest dal modulo WebAssembly quindi io posso chiamare il main io chiamo il main del modulo WebAssembly dal host non so se... che figlia... si si si ho capito e quindi praticamente poi quello la il main avrà il valore assoluto che è la funzione che io gli ho passato dall'inker esatto ok e poi c'è tutto un discorso che il modulo l'istanza ha una sua memoria sua memoria, ok? E questa memoria io dal lato host la posso vedere, ok? O volendo, facendo cose un po' di basso livello, posso anche smanettarci dentro. E quindi per esempio... Cioè puoi usare la Unix pipe dei poveri dei WebAssembly, cioè gli scrivi la roba? Questo è il modo con cui tutti i meccanismi di estensione funzionano. Per esempio... posso andare a dirgli, c'è per esempio un protocollo di comunicazione adesso c'è tutto un meccanismo che si chiama di interfacce, di WebAssembly che vanno a praticamente, tu definisci con un linguaggio di modellazione quella che è l'API, per esempio per interagire con un Key Value Store quindi tu definisci con questo linguaggio quali sono i contratti di questa API e dopo di che c'è un Code Generator che ti genera il codice sia per il guest che poi diventa la libreria che vado ad includere quindi ti genera il codice guest per Rust, per esempio quindi tu scrivi del codice client, il guest Rust che importa dentro questa funzione e poi ti scrive anche quelle che sono i tipi per l'host nel contesto di Rust, per esempio quando ti genera il codice per l'host ti genera dei tratti, dei trait che poi tu, dopo, quando vai a crearti il tuo runtime ad hoc il runtime ad hoc perché deve supportare questo API che tu sei appena creato vai a implementare questo tratto in una tua struttura dati e poi tutta una serie di meccanismi per registrarlo nel runtime se invece avessi fatto creare la cosa molto figa è che ovviamente io poi posso creare per esempio il codice lato host con un generatore per esempio di Go e questo mi genererà per esempio delle interfacce di Go che poi dopo vado a implementare e passare in qualche modo e poi sotto a livello basso Tutta questa magia per mandare avanti e indietro i dati, visto che come dicevo prima ci sono quattro tipi di dati, viene fatta tutta andando a lavorare sulla memoria, facendoci che c'è tutto questo processo di comunicazione per cui l'host scrive in determinate re di memoria, il guest lo legge, risponde da un'altra parte. E' tutto sized, perché chiaramente devi andare proprio a scrivere là dentro. Bellissimo. e questo è molto potente e quello su cui si sta lavorando tantissimo adesso è il component moder per cui io posso andare, per esempio, a scrivere del codice o un programma che deve fare una serie di operazioni e voglio scrivere tutto in WebAssembly faccio un esempio stupidissimo devo verificare controlli sulle versioni semantiche quindi ho bisogno di una libreria che sia in grado di fare parsing di una stringa che ha delle versioni semantiche produrre una serie di oggetti e magari gli dai in ingresso due stringhe che sono due versioni -1, 0, 1, 2, 6, maggiore o minore o uguale io posso scrivere questo codice come libreria come progetto di base scrivo un progetto che sarà una libreria e lo scrivo per esempio in rasta perché mi piace una libreria di semantic version iscritta in rasta dopodiché però questa libreria la voglio consumare da un'altra parte, da un'altra porzione del mio programma magari una porzione che gestisce l'input e l'output di traffico HTTP questa la scrivo in Go quindi alla fine ottengo due librerie che sono tutte e due dei file WOSM con il component model posso far sì che la libreria scritta in Go invochi la funzione che si trova nell'altro modulo scritto in Rust e sono in grado di comunicare tra di loro. Poi si va a creare quello che è un unico modulo WOSM, all'interno del quale ci sono questi due sottomoduli, ognuno dei quali isolati l'uno dall'altro, ma che sono in grado di comunicare l'uno con l'altro e possono essere consumati all'esterno. - Questa è interessante, però, perché non avendo WOSM, tutte le cose "fiche", tipo la sync, e quindi non è limitato. - Sì, è sempre limitato dal run time, da quello che è possibile fare una specifica, però diciamo che si aprono degli scenari parecchio interessanti. - Sì, a livello di semantica comunque sì. Nel senso, se ti piace, se un team piace Rust, e un team piace Go, invece di Rust e Isassi a quel punto fanno... o anche il fatto di avere librerie che non sono scritte in altre linguaggi di programmazione per esempio, so che tu l'hai usato, c'è RAI che è un linguaggio di scripting scritto in Rust che però è scritto solo in Rust quindi non lo puoi usare per esempio in Go io potrei crearmi un modulo WebAssembly all'interno del quale metto l'engine di Rai che espone delle API che io decido e poi lo posso chiamare direttamente da un programma scritto in Go all'interno del quale metto un runtime WebAssembly e quindi dal mio programma in Go posso andare a fare chiamate su questo modulo e quindi utilizzare l'engine di Rai da Go senza bisogno di aspettare qualcuno che faccia il porting. Quindi combinazione al posto dei vari function interface, bellissimo. Ci sono un po' di approcci interessanti. Poi ecco tutta una serie di... adesso stiamo parlando tanto di WebAssembly per lato server quindi lo vediamo per andare a implementare si presta molto bene per le FAS però un altro meccanismo di uso molto potente di WebAssembly è quello di andare a estendere dei programmi tramite dei plugin che però vengono scritti in WebAssembly che è quello che facciamo con CubeWarden c'è un editor un po' hipster che si può arricchire tramite moduli WebAssembly plugin scritti come moduli WebAssembly ci sono un po' di programmi che fanno tutto questo. Hai menzionato Qubeworden, quindi a questo punto io penso che siamo pronti per entrare nella dana del bianconiglio, ovvero WebAssembly e Kubernetes, qual è lo stato delle cose e soprattutto introducici a Qubeworden. Ok, allora, KubeWarden è il motivo per cui sono andato a scoprire WebAssembly. Si tratta di un admission controller di Kubernetes, che per i non avvezzi a Kubernetes fa un meccanismo di sicurezza, di compliance, di validazione. Praticamente ogni qualvolta tu all'interno di Kubernetes stai per fare, sta per avvenire qualcosa, per esempio decidi di creare un deployment, fai "do kubectl apply" con un file di emol con dentro la definizione "deployment", questo genera un evento, una richiesta, che deve essere o accettato o rifiutato, eventualmente modificato da un admission controller. Per esempio, tutti i discorsi di "non vogliamo far girare container privilegiati all'interno di Kubernetes" sono tutti una serie di controlli che vengono fatti da degli admission controller. Kubernetes ha una serie di admission controller al suo interno però non possono coprire tutti i casi d'uso per esempio non voglio che all'interno del mio cluster giri un'immagine che provenga dal docker hub per esempio non ha un admission controller che blocca l'immagine di docker hub per fare tutto questo ti devi appoggiare a un webhook server esterno un dynamic admission controller che è implementato tramite un webhook server che tu registri in Kubernetes e gli dici ogni volta che un deployment sta per essere creato o modificato prima valida l'evento mandando un payload a questo webhook server. Ci sono un po' di soluzioni che operano in questo contesto per chi ha il mondo Kubernetes, avrà di sicuro sentito Gatekeeper o Caverno, per esempio. Un'altra di queste soluzioni è Qboard, che è un progetto sia in Cf anche S come gli altri due, il quale ha come distinzione il fatto che tutte queste piattaforme sono delle policies da service, sono delle FAS che eseguono policies di Kubernetes. Il modo con cui funzionano le altre due soluzioni è quello di obbligarti a utilizzare un determinato modulo per scrivere le policies. Quindi nel caso di Gatekeeper, che impari questo linguaggio che si chiama Rigo, che è specifico, nel caso di Caeverno ti metti a scrivere dello YAML che è stato esteso con delle keyword, allora che è diventato praticamente un linguaggio. La sfida che mi era stata lanciata era quella di dire "ma ci sarà un modo per non vincolare l'autore di una policy a utilizzare Rigo o questo YAML?" e quindi mi è venuta l'idea di provare a utilizzare WebAssembly e questo è quello che fa QubeWorden alla fine ti permetti da un SDK con la quale scrivi delle policy per QubeWorden che ti permettono di fare la validazione di oggetti Kubernetes utilizzando diversi linguaggi di programmazione queste policy vengono compilate in moduli WASM che poi vengono distribuiti come OCI artifacts all'interno di container register, quindi di stessi container register che mettono le immagini, ci mettono questi moduli, e poi dopo a livello di runtime abbiamo un nostro web server che espone degli endpoint che vengono interpellati dall'API server di Kubernetes e vanno ad eseguire dentro delle sandbox on demand queste policy. Quindi questo è un modo per prendere il modo con cui funziona l'architettura plugin, quindi hai un server che poi viene arricchito come funzionalità, quindi guadagna diversi modi di validare o di modificare le risorse caricando dei programmi iscritti in WebAssembly. Quindi questo è un modo molto specifico di usare WebAssembly ed è un modo che per esempio viene usato anche da altri progetti, per esempio Istio o addirittura a livello più basso Envoy, ti permette di andare a fare delle regole che possono essere scritte anche lì in webhustler. Penso che sia Istio più che Envoy, però non mi ricordo dove abbiano spostato Runtime effettivamente. Ok, questo non lo sapevo perché io pensavo che Finamoso fosse tipo... Cioè, quando prima mai parlato di Kubernetes e WebAssembly in generale, ho detto "ah, ma io pensavo che KubeWord fosse la prima cosa che usava". Abbiamo fatto da apripista, onestamente, quello sì. E poi è un approccio che comunque si è dimostrato valido e altri lo stanno utilizzando in altri contesti. tra l'altro adesso è venuto a Istio che ha il supporto a Wozzem la cosa interessante è che hanno anche creato un runtime di WebAssembly che è scritto in Go e non ha dipendenze esterne perché tutti gli altri runtime sono per esempio i binding per woz and time però questo vuol dire che il tuo binario go non è più un binario compilato staticamente ma diventa un binario che è linkato su una libreria di woz and time e quindi questo in alcuni contesti va un po' a rompere le scatole invece hanno inventato questo runtime che è woz zero che è scritto in puro Go e quindi ha due dipendenze esterne è ottenuto dal binario statico non è performante tanto quanto Wosentime però per i casi d'uso che hanno va benissimo e poi stanno lavorando tanto poi magari adesso è diventato tanto quanto veloce quindi che non si offendano gli eventuali maintainer in ascolto di cui solo c'è un italiano di Milano che ci lavora quindi questo è un aspetto Però la cosa che invece forse è più interessante, hai più, è il fatto di andare a eseguire programmi scritti in WebAssembly su Kubernetes stesso. Quindi qua c'è tutto il filone di... sembra un pod, ma in realtà non è un container, è un modulo WebAssembly che gira nel cluster. Quindi il discorso di avere dei modi per cui tu scrivi la definizione, fa gli emol di un pod, di un deployment di Kubernetes, qualsiasi cosa che al suo interno abbia un container, e ci metti dentro l'indirizzo a un registry, però invece che esserci un'immagine OCI all'interno di quel riferimento c'è un modulo WebAssembly che poi viene eseguito. Quindi questo è tutto il filone di andare un po' come Kubernetes, si può estendere e avere dei container che girano come container Linux ma avere anche delle macchine virtuali che girano all'interno di un cluster penso tipo a Cubevert ok cerco di non parlare invece di secure containers quindi cose come GVize o Rokata Container dove hai dei microcontainer delle micro VM, scusate quindi hai un container che gira all'interno di un'avm minuscola per motivi di sicurezza però all'esterno, quando tu usi tutte le API di Kubernetes, KubeCTL o qualsiasi interfaccia sembrano dei pod, si comportano come pod così c'è tutto un lavoro in atto per eseguire codice WebAssembly all'interno di Kubernetes direttamente con vcrd quindi No, no, no, c'è una CRD, questa è la cosa bella. No, come non c'è una CRD? In che senso? Praticamente tu ti prendi la tua applicazione iscritta con il framework di Spin, per esempio, e te la fai girare con il tool da linea di comando Spin sul tuo portatile, ok? E gira, tranquillo. Dopodiché, questa applicazione, senza doverla ricompilare, ne fai il push su un registry, ok, e poi su un cluster che è stato opportunatamente configurato, tu scrivi un pod, la definizione di un pod, di kubernetes open object pod. Kind deployment. Esatto. Esatto, ci metti dentro il link a dove è fatto il push del modulo WOSAM, con spin push, se non sbaglio, se non ricordo male, e dopodiché questo pod viene schedulato all'interno del cluster. Dopodiché ci crei un service, come fai con tutti i workloads che puoi esporre in Kubernetes, ci crei un ingress, come fai tranquillamente, e a quel punto vai sull'ingress e ti trovi davanti il tuo hello world che è stato scritto in iWASM, che è erogato da un modulo WASM che sta girando all'interno di Kubernetes. No, vabbè, ma hai appena fatto il movimento Geodrop. ma dentro un container, però in realtà no in realtà no QubeWarden quando gira, gira in Kubernetes ovviamente e CubeWarden lo fa, come dicevo prima ha un meccanismo di utilizza WOSAN per arricchire un'applicazione come un plugin, quindi noi abbiamo un container che ha al suo interno una container image che ha al suo interno un binario RAST che è il nostro policy server, lo chiamiamo il quale poi ha un container vero e proprio, che è tradizionale e poi lui si scarica in moduli WOSM leggendo da un file di configurazione e quindi noi funzioniamo così è un'applicazione come qualsiasi altra applicazione che gira in Kubernetes invece questo livello di integrazione è molto più spinto e praticamente funziona così ditemi se vado troppo... No, no, vai, vai, mena, mena. Allora, praticamente c'è... tu in Kubernetes hai sui nodi, sui worker nodes, hai il processo kubelet che sta lì in ascolto e dice che cosa è schedulato su me, su questo node su cui sto girando. Riceve le istruzioni e poi si va a interfacciare tramite una specifica che si chiama container runtime interface a un container runtime. Un tempo il container runtime era Docker, all'alba dei tempi, quindi Qubelet parlava con Docker, dopodiché, io sono uno di quelli che è in Kubernetes dalla notte dei tempi, c'è stato un progetto di XCore OS che si chiama Rocket, che era un runtime alternativo. E quindi è stata definita questa interfaccia, questa API che sta tra Qubelet e quelli che sono i runtime generici alternativi. quindi grazie a questo lavoro è possibile andare a utilizzare diversi container run time per esempio Docker oramai non lo si usa più ed è stato sostituito da container D se tu invece prendi OpenShift e in OpenShift hanno Cryo, che è un'altra implementazione quindi a livello di run time tu gli dici "non eseguiamo" è a un livello ancora più sotto, perché qua in realtà c'è un altro livello di indirezione tu hai il container D, il quale poi predispone tutto l'ambiente per quello che è il container per esempio è quello che si occupa di fare il pull dei layer di un'immagine di preparare il percorso sull'host in cui c'è il root file system della container di immagine, espanso e quant'altro e poi dopo c'è un runtime o CI che va effettivamente a eseguire il tutto e l'implementazione di riferimento è run C quindi tu hai Qubelet, Containerd e poi IRAMC. Ci sono delle specifiche in tutti i punti, tra Qubelet e Containerd e tra Containerd e IRAMC. L'ultima è lo CIROM Time Specification, quella che sta tra Containerd e IRAMC. È della stessa specifica che rispetta anche CRIO. Craio per parlare con RunC ci parla utilizzando la stessa interfaccia. Ok? A un certo punto, cosa si è detto? Vogliamo trovare altri modi per eseguire container, cioè container sono sicuri, ma fino a un certo punto. L'implementazione di RunC è basata su Kernel namespace, sui Kernel cgroups e quant'altro, però non offre un livello di isolamento così potente come una macchina virtuale tradizionale. e quindi sono stati creati altri progetti, tra cui per esempio Kata o Gvisor i quali praticamente hanno un'implementazione della runtime, ossia i specification quindi non c'è più Run C, ma per esempio c'è Run V, che è quello di Gvisor oppure c'è, non mi ricordo come si chiami quello di Kata e quindi cosa succede? che tu stai ancora parlando di container normali quindi tu... cosa è stato fatto in kubernetes? è stato introdotto un field all'interno delle specifiche del container per cui tu puoi dire non far girare questo container con il runtime di default del cluster invece farlo girare con questa runtime class c'è una CRD che si chiama runtime class dove tu dici in questo cluster io amministratore mi sono sbattuto, ho installato i binari di RunV, di Gvisor ho configurato container D in maniera tale che tra i vari runtime che li conosce oltre a RunC che è il suo default c'è anche RunV quindi io ti creo questo oggetto, RunTime class, in Kubernetes e poi io come utente finale vado a scrivere dentro la mia spec del deployment del pod e quant'altro, gli dico che il runtime da utilizzare è runv. E quindi questa informazione viene fatta arrivare giù, fino in basso, fino a containerd, il quale quando fa lo spawning del container non utilizza runc ma usa runv. Questo meccanismo del runtime è stato, tra virgolette, abusato anche nel contesto di WebAssembly. E quindi io posso dire, c'ho runwasm. Esatto. come run time, posso usare run wasm e gli dico "fabula quello" C'è un progetto che si chiama run wasi che implementa questa specifica è scritto in Rust, implementa una serie di tratti che implementano la run time che non implementano la run time praticamente è un modo per scrivere dei runner diciamo così, dei wasm, per container D quindi implementa la specifica che il container dia al suo interno per essere speso con questi altri meccanismi di plugin. Quindi implementa questi trait e dopo di che questi trait vengono concretizzati in quelli che vengono chiamati degli shim. Quindi per esempio c'è uno shim di spin che praticamente implementa questa interfaccia di Ranwasi andando ad utilizzare sotto un runtime di SPIM c'è poi un altro che è il runtime di Spider Lightning che è un altro framework e ce ne sono vari e quindi tu puoi avere un cluster in cui è configurato macchine virtuali vere e proprie che girano con CubeVert micro VM che girano con Kata per far girare i pod tradizionali però dentro una macchina virtuale per motivi di sicurezza. E poi puoi avere dei workload che sono scritti in WASM, con spin, per esempio, che girano all'interno del tuo cluster. Quindi non hai un container all'interno del quale c'è un programma scritto in Rust come QWert, come QWord. Quindi questo è il meccanismo di funzionamento. La cosa affascinante è che poi tutto quanto va a incastrarsi perfettamente in quello che è un modello di Kubernetes, quindi non so, gli monti un volume per leggere e scrivere, poi in modo luogo se non ci legge e scrive è trasparente a lui, così come nel discorso del networking e quant'altro, per esempio il service ingress, bla bla bla, funziona allo stesso modo. Ci sono dei lavori, è una roba molto recente questa addirittura, per far sì che questo genere di workload, WOSM, vengano utilizzati come sidecar, per esempio, all'interno dei pod, perciò andare a ridurre quello che è l'overhead introdotto dai sidecar. Però questa è roba super sperimentata, cioè tutto è in divenire, non esistono libri, è roba che vai e leggi e parli con la gente, quindi è tutto all'avanguardia. però se volete sviluppare qualcosa, spin, ribadisco, wasmicloud sono interessanti ok, ok, guarda, ti abbiamo... allora io non so se Leonardo ha delle domande perché ti abbiamo tenuto prigioniero per un'ora e un quarto no, no, no, no, io sono stato... guarda ho preso tutta una serie di appunti... ah non si vede... una serie di appunti, keyword, di cose perché sono interessanti, ma io sono praticamente nulo di queste cose, cioè ho qualche concetto di kubernetes, però sentire di come in realtà questo ecosistema dentro ci stanno filando di tutto e poi mi dici "sì, combacia tutto perfettamente" è affascinante da sentire. Sai che mi sembra... voi l'avete visto Westworld? Sì, anche se ho mollato, non lo so, tipo alla terza. A me sembra quando... sì, vabbè, la terza era allucinante, veramente poca ispirazione autoriale, però loro a un certo punto programmavano sti robot e li prendevano, cacciavano fuori sto tablet e scrivevano ste funzioni e non si capisce bene dove le pusciavano, gliele pusciavano in testa e certe volte a me sembra che stiamo cominciando a raggiungere un tipo di tecnologia molto da cyberpunk, dove tu apri il tuo cyberdeck, scrivi la roba e la una push non si sa dove e quella si scarica, il lifecycle è tutto automatizzato, è bellissimo. Scusate questa digressione. Avevo ripreso la tab che l'avevo lasciata aperta di Wosmcloud, che la punchline è semplicemente molto umilmente "build applications in any language, deploy them anywhere". Questa roba qua praticamente. Scrivi come ti pare, dopo dove ti pare. credibile credibile io a questo punto darei il via a eh tutta una serie di di segmenti finali che io non sono assolutamente qualificato per condurre quindi come sempre degliato una mano di una no allora ehm quali sono abbiamo? Eh abbiamo dei ringraziamenti da fare? Allora questa settimana a me non sono quindi non so se abbiamo ringraziamenti da fare. Siamo in autogestione quindi non abbiamo tutte le informazioni sotto mano. No, abbiamo i nostri contatti, che non so se avete detto all'inizio, perché io giustamente visto che siamo in autogestione sono arrivato. No, non li abbiamo detti all'inizio e io ovviamente mi riservo subito lo spot delle donazioni. che è con questo, con i vostri soldi che noi manteniamo vivo Mauro in cantina. Esatto, esatto, esatto. Le teste di pesce costano perché comunque ha aumentato tutto. E quindi se volete farci sapere qualcosa noi siamo su Telegram che è il nostro canale principale, quindi ci cercate con la Gitbar. Info. Se Aruba ha sistemato i server, ma credo di sì, io credo che nessuno abbia mai usato l'email visto che comunque gli ospiti li invitiamo noi come con le nostre mail personali e Brian Riffo su Twitter o X la stessa cosa quindi questi sono i nostri contatti. Poi il canale YouTube iscrivetevi, mettete la campanella qua sotto 6 punti per apprendicette. Esatto! Siamo proprio nati col marketing nel sangue. 5 stelle su Spotify dicono tutti i podcast. Quello è importantissimo, penso. Esatto, esatto. Su Github.it potete trovare anche tutto il resto di informazioni che noi ora non abbiamo lì. Andiamo a braccio, oggi ci va Twitter, domani guardiamo Telegram. Invece per per le donazioni abbiamo già detto donazioni, donate, tutto Waki Parpunto andate in questi canali troverete sicuramente il link per donare perché saranno tipo copriteci di soldi ragazzi perché guarda Mauro Costa mangia è secco quel ragazzo ma mangia un sacco. Piccolo ma ma mangia. E direi che siamo arrivati al momento tipico e topico del nostro podcast che è il Paese dei Balocchi ossia i nostri guest, i nostri host, ci propongono una chicca o un qualcosa che li ha intrattenuti per un tempo che va dai 10 secondi al 20 anni di carriera e che possono essere utili alla nostra community. Allora, inizio io visto che non lo avevo, io ho tenuto la collezione dei libri che sono stati nominati in questa puntata, così che chi vuole come me iniziare a vedere WebAssembly, ha già una lista di 3 o 4 che abbiamo nominato per introdurre e poi andare nella giungla di informazioni che si possono trovare in rete, che immagino siano quelle più aggiornate. Flavio, hai un balocco per noi. Mamma mia, ho già smocciolato un po', direi spin. Guardatevi spin, guardatevi i tutorial che hanno. sono molto ben fatti passo passo e concreti perfetto io invece vi porto perché semplicemente è una cosa bella che ho finito da qualche giorno la trilogia del problema dei tre corpi e il libro e ho finito tutti e tre i libri e ve la consiglio perché è fuori di testa come me tanta roba sì Ho guardato anche la serie tv che è fatta inaspettatamente molto bene, non so che opinione avete delle serie Netflix. La cosa allucinante però è che io rispetto al libro, la serie è molto occidentalizzata, invece il libro è molto cinese, i protagonisti si chiamano cinese, fa molto riferimento alla che è un'altra cosa che mi ha arricchito nella civiltà cinese sia come modello comportamentale che come usanze quindi è l'ho trovato veramente che mi ha mi ha arricchito detto ciò ragazzi siamo arrivati anche questa volta alla fine io ringrazio Flavio per averci concesso un po' del suo tempo che è veramente eh tipo tipo Abbiamo rubato una masterclass fondamentalmente. Grazie davvero per la competenza che hai condiviso con noi. Noi siamo ai saluti, sapete dove trovarci e noi ritorneremo sicuramente entro pochissimi giorni su sul nostro podcast visto le pubblicazioni d'estate vanno un po' sono un po' meno a bere in ferie esatto esatto la gente in spiaggia vuole non vuole sentire noi probabilmente e reggaeton ma forse sarà uscito qualche altro genere musicale nel 2024 vedremo io fatico nonostante tutto l'avvento della trap le cose eccetera io fatico a trovare qualcosa di più molesto del reggaeton. Cioè, secondo me è proprio la cosa più brutta uscita fino adesso, a parte quel nordic reggaeton dei men. Bello, non vedo l'ora di sentire, sì, comunque mi trovi d'accordo su quello. Ci dispiace per gli ascoltatori, che non saranno molti, credo, che adorano il reggaeton. Detto questo, allora salutiamo tutti. Grazie ancora, Flavio, di essere ci vediamo alla prossima, ciao! [Musica] [Silenzio]