---
youtubeUrl: https://www.youtube.com/watch?v=daqWyDrRFzY
---

## Descrizione

Episodio speciale di Gitbar con Giacomo Cavalieri, membro del core team di Gleam. Esploriamo questo linguaggio funzionale giovane ma promettente che compila sia su Erlang/BEAM che JavaScript. Discutiamo della filosofia di design minimalista di Gleam, del perché la semplicità può essere un superpotere, e come una community accogliente può fare la differenza. Parliamo anche di career progression, dell'importanza di chiedere feedback, e di come liberarsi dal superfluo sia nel codice che nella vita. Un episodio che mescola tecnica, filosofia di design e crescita personale.

## Takeaway

- Gleam è un linguaggio funzionale semplice e tipato che compila su Erlang/BEAM e JavaScript, con un focus maniacale sulla semplicità: poche feature ortogonali ma potenti
- Il compilatore di Gleam produce codice Erlang pulito e leggibile, permettendo ottima interoperabilità con l'ecosistema BEAM senza perdere i vantaggi del sistema di tipi
- La community fa il linguaggio: Gleam ha una delle community più accoglienti del panorama tech, e questo è un fattore chiave per il successo del progetto
- Il language server e il tooling (package manager, formatter) sono integrati direttamente nel compilatore, following la filosofia "batteries included" senza configurazione
- L'esperienza di lavorare su un compilatore open source in Rust è più accessibile di quanto si pensi: con curiosità e umiltà nel chiedere aiuto, tutti possono contribuire

## Bold Opinion

- TypeScript ha un type system troppo complesso: debuggare i tipi oltre ai valori è un antipattern, e la magia dei conditional types e mapped types rende il codice impossibile da mantenere
- Essere proattivi sul lavoro può infastidire: c'è un limite sottile tra essere proattivo e rompere le scatole, e bisogna trovare il giusto equilibrio
- Un linguaggio con un "benevolo dittatore" che dice no a feature può essere rischioso per un'azienda: affidare decisioni critiche a una singola persona, per quanto capace, è un rischio che va considerato
- La metaprogrammazione è spesso un accrocchio: nel 90% dei casi se stai scrivendo una macro, probabilmente c'è un modo migliore di risolvere il problema