---
---

## Descrizione

In questa puntata ospitiamo Marco Perone (marcoshuttle), matematico pentito diventato categorical developer, che ci fa esplorare il mondo della programmazione funzionale. Parliamo di funtori, monadi (e del perché se le capisci perdi l'abilità di spiegarle), di come i tipi possano modellare un dominio meglio di mille righe di codice, e di come scrivere PHP funzionale senza impazzire grazie a Psalm. Scopriamo anche perché Elm è meglio di Scala per iniziare, e come mai le monadi sono solo "scatolette nel contesto".

## Takeaway

- **Programmazione funzionale e reactive sono cose diverse**: La reactive lavora su stream di dati che si aggiornano nel tempo. La funzionale usa funzioni come oggetti di primo ordine e tipi fortemente espressivi per descrivere esattamente cosa fa il codice.
- **DDD e funzionale sono una coppia quasi perfetta**: Value objects immutabili, event sourcing come fold degli eventi, modellare il dominio solo con tipi prodotto e somma. Peccato che DDD sia nato in un mondo ad oggetti, ma le idee vengono dalla funzionale.
- **I funtori sono contesti in cui lavoriamo**: Un `Maybe B` significa "forse ho un B, forse no". Rappresentiamo la possibile assenza di valori, il fallimento, gli effetti collaterali, tutto a livello di type system invece che nasconderlo nel codice.
- **Le monadi permettono di comporre funzioni in un contesto**: La monade è un funtore che ci dà il "bind" per comporre funzioni che ritornano valori dentro una "scatoletta". Così possiamo scrivere codice modulare anche con effetti espliciti.
- **PHP funzionale è possibile con Psalm/PHPStan**: Usarli come compilatori, farli girare a ogni salvataggio, annotare tutto con i tipi. La developer experience non è magnifica ma il risultato è codice di ottima qualità. E puoi eliminare tonnellate di test unitari.

## Bold Opinion

- **Elm > Scala per imparare**: Scala ti permette di continuare a fare programmazione oggetti e non ti costringe a cambiare paradigma. Elm ha una sintassi diversa (scoglio iniziale), ma una volta superata ti obbliga a pensare funzionale davvero.
- **I pattern della Gang of Four sono funzioni travestite**: Decorator? Composizione di funzioni. Strategy? Una funzione. Factory? Una funzione che ritorna qualcosa. Il 90% dei pattern è boilerplate inutile che sparisce con la funzionale.
- **Linguaggi fortemente tipati > test unitari**: Se esprimi la business logic nel type system, il compilatore controlla per te. Non serve scrivere test per verificare che una cosa faccia quello che gli hai chiesto, perché qualcun altro lo sta già controllando.
- **I side effects vanno resi espliciti**: In programmazione procedurale gli effetti collaterali sono nascosti nel codice. In funzionale sono rappresentati a livello di tipi. Vuoi scrivere su file? Il tipo della funzione lo dichiara. Zero sorprese.

