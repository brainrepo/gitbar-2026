---
youtubeUrl: https://www.youtube.com/watch?v=rYayuViGSoQ
---

## Descrizione

In questa puntata ci immergiamo nel mondo del CQRS (Command Query Responsibility Segregation) e dell'Event Sourcing insieme a Carmine e Alessio. Parliamo di come separare la scrittura dalla lettura, di aggregati che vivono in memoria e di come Elixir con Commanded ci permetta di fare cose pazzesche. Non è un crude mascherato, giuriamo! È un modo diverso di pensare le nostre applicazioni dove gli eventi sono protagonisti e la storia conta davvero.

## Takeaway

- CQRS non è solo "crude fatto male" ma una vera separazione tra comandi (scrittura) e query (lettura) con proiezioni dedicate
- Event Sourcing ti permette di ricostruire lo stato dell'aggregato riproducendo tutti gli eventi: è come avere una macchina del tempo per il tuo dominio
- Gli aggregati sono entità che vivono in memoria con uno stato interno che cambia reagendo a comandi ed emettendo eventi
- L'event roll-up è fondamentale per la gestione a lungo termine: come chiudere il libro mastro a fine anno senza perdere lo storico
- Il micro service che gestiamo ha CQRS per alcune parti e crude per altre: non sono approcci esclusivi ma complementari

## Bold Opinion

- Se stai facendo microservizi, o usi CQRS/ES o finisci per reimplementarlo pezzo per pezzo (magari male)
- Domain Driven Design e CQRS in PHP è un inferno: Node non è fatto per tenere stato a lungo, meglio Elixir con la BIM che ti tiene gli aggregati in memoria per sempre
- Nest.js è troppo: se vuoi Java fai Java con una JVM seria, non Node con annotazioni ovunque che alla fine cancelli i node_modules e gira uguale
- L'event sourcing non è per tutti: se non ti interessa lo storico e hai paura del disco pieno, forse il buon vecchio Postgres basta e avanza